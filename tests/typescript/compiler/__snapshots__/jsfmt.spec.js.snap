// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`ClassDeclaration22.ts 1`] = `
class C {
    "foo"();
    "bar"() { }
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
class C {
  foo();
  bar() {}
}

`;

exports[`badArrayIndex.ts 1`] = `
var results = number[];
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
var results = number[];

`;

exports[`checkInfiniteExpansionTermination.ts 1`] = `
// Regression test for #1002
// Before fix this code would cause infinite loop

interface IObservable<T> {
    n: IObservable<T[]>; // Needed, must be T[]
}

// Needed
interface ISubject<T> extends IObservable<T> { }

interface Foo { x }
interface Bar { y }

var values: IObservable<Foo>;
var values2: ISubject<Bar>;
values = values2;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Regression test for #1002
// Before fix this code would cause infinite loop

interface IObservable<T> {
  n: IObservable<T[]> // Needed, must be T[]
}

// Needed
interface ISubject<T> extends IObservable<T> {}

interface Foo { x }
interface Bar { y }

var values: IObservable<Foo>;
var values2: ISubject<Bar>;
values = values2;

`;

exports[`commentInNamespaceDeclarationWithIdentifierPathName.ts 1`] = `
ï»¿namespace hello.hi.world
{
    function foo() {}
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
namespace hello.hi.world {
  function foo() {
  }
}

`;

exports[`commentsInterface.ts 1`] = `
interface i2 {
    foo: (/**param help*/b: number) => string;
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interface i2 {
  foo: (/**param help*/ b: number) => string
}

`;

exports[`functionOverloadsOnGenericArity1.ts 1`] = `
// overloading on arity not allowed
interface C {
   f<T>(): string;
   f<T, U>(): string; 
 
   <T>(): string;
   <T, U>(): string; 
 
  new <T>(): string;
  new <T, U>(): string; 
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// overloading on arity not allowed
interface C {
  f<T>(): string,
  f<T, U>(): string,

  <T>(): string,
  <T, U>(): string,

  new <T>(): string,
  new <T, U>(): string
}

`;

exports[`indexSignatureWithInitializer.ts 1`] = `
// These used to be indexers, now they are computed properties
interface I {
    [x = '']: string;
}

class C {
    [x = 0]: string
}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// These used to be indexers, now they are computed properties
interface I {
  [x = ""]: string
}

class C {
  [x = 0]: string;
}

`;

exports[`mappedTypeWithCombinedTypeMappers.ts 1`] = `
// Repro from #13351

type Meta<T, A> = {
    [P in keyof T]: {
        value: T[P];
        also: A;
        readonly children: Meta<T[P], A>;
    };
}

interface Input {
    x: string;
    y: number;
}

declare const output: Meta<Input, boolean>;

const shouldFail: { important: boolean } = output.x.children;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Repro from #13351

type Meta<T, A> = {
  [P in keyof T]: {
    value: T[P],
    also: A,
    readonly children: Meta<T[P], A>
  }
};

interface Input {
  x: string,
  y: number
}

declare const output: Meta<Input, boolean>;

const shouldFail: { important: boolean } = output.x.children;

`;

exports[`modifiersOnInterfaceIndexSignature1.ts 1`] = `
interface I {
  public [a: string]: number;
}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interface I {
  public [a: string]: number
}

`;
