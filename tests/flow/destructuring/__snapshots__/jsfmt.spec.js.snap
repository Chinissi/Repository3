// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`annot.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow
var {p}: T = {p: "foo"};
p = 42; // error: number ~> string
type T = {p: string};

=====================================output=====================================
// @flow
var { p }: T = { p: "foo" };
p = 42; // error: number ~> string
type T = { p: string };

================================================================================
`;

exports[`annot_loop.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

// Destructuring self-referential annotations should terminate.

type T = T;
function f({p}: T) {
  p = 0;
}


// Including tricky cases

type A = B;
type B = A;
function g({p}: A) {
  p = 0;
}
function h({p}: B) {
  p = 0;
}

=====================================output=====================================
// @flow

// Destructuring self-referential annotations should terminate.

type T = T;
function f({ p }: T) {
  p = 0;
}

// Including tricky cases

type A = B;
type B = A;
function g({ p }: A) {
  p = 0;
}
function h({ p }: B) {
  p = 0;
}

================================================================================
`;

exports[`array_rest.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
let xs = [0, "", true];
let [a, ...ys] = xs;
let [b, ...zs] = ys;
let c = zs[0]; // retain tuple info
let d = zs[1]; // run off the end

(a: void); // error: number ~> void
(b: void); // error: string ~> void
(c: void); // error: boolean ~> void
(d: void); // error: number|string|boolean ~> void

let [...e] = 0;

=====================================output=====================================
let xs = [0, "", true];
let [a, ...ys] = xs;
let [b, ...zs] = ys;
let c = zs[0]; // retain tuple info
let d = zs[1]; // run off the end

(a: void); // error: number ~> void
(b: void); // error: string ~> void
(c: void); // error: boolean ~> void
(d: void); // error: number|string|boolean ~> void

let [...e] = 0;

================================================================================
`;

exports[`bad_annot.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

/* The code in this test has a confusing error and should be improved.
 * Bindings that result from destructuring an annotation should themselves
 * behave like annotations. In some cases, annotations are not recursively
 * annotations, like the class example below.
 *
 * For now, we use some sketchy unification logic to pin things down, but it
 * does not behave sensibly for tvars with incompatible lower bounds.
 *
 * Ideally annotations would be recursively annotations, instead of shallowly.
 * Another possibility would be to forego the annotation behavior for these
 * kinds of destructurings.
 */

class C {
  p;
  m(cond: boolean) {
    if (cond) {
      this.p = 0;
    } else {
      this.p = "";
    }
  }
}

function f({
  p // weird: string ~/~> number. C#p is inferred, with both number and string inflows
}: C) {
  p = null; // weird: null ~/~> number. we pinned \`p\` to \`number\`
}

=====================================output=====================================
// @flow

/* The code in this test has a confusing error and should be improved.
 * Bindings that result from destructuring an annotation should themselves
 * behave like annotations. In some cases, annotations are not recursively
 * annotations, like the class example below.
 *
 * For now, we use some sketchy unification logic to pin things down, but it
 * does not behave sensibly for tvars with incompatible lower bounds.
 *
 * Ideally annotations would be recursively annotations, instead of shallowly.
 * Another possibility would be to forego the annotation behavior for these
 * kinds of destructurings.
 */

class C {
  p;
  m(cond: boolean) {
    if (cond) {
      this.p = 0;
    } else {
      this.p = "";
    }
  }
}

function f({
  p, // weird: string ~/~> number. C#p is inferred, with both number and string inflows
}: C) {
  p = null; // weird: null ~/~> number. we pinned \`p\` to \`number\`
}

================================================================================
`;

exports[`computed.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
var { ["key"]: val1 } = { key: "val" };
(val1: void); // error: string ~> void

var key: string = "key";
var { [key]: val2 } = { key: "val" };
(val2: void); // ok (gasp!) by existing StrT -> ElemT rule

var { ["key"]: val3, ...spread } = { key: "val" };
(spread.key: void); // error (gasp!) in general we don't know if a computed prop should be excluded from spread

=====================================output=====================================
var { ["key"]: val1 } = { key: "val" };
(val1: void); // error: string ~> void

var key: string = "key";
var { [key]: val2 } = { key: "val" };
(val2: void); // ok (gasp!) by existing StrT -> ElemT rule

var { ["key"]: val3, ...spread } = { key: "val" };
(spread.key: void); // error (gasp!) in general we don't know if a computed prop should be excluded from spread

================================================================================
`;

exports[`defaults.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/* @flow */

function obj_prop_fun({p:{q=0}={q:true}}={p:{q:""}}) {
  // errors:
  // * number  ~> void, from default on _.p.q
  // * boolean ~> void, from default on _.p
  // * string  ~> void, from default on _
  // * null    ~> void, from call below
  (q:void);
}
obj_prop_fun(); // ok
obj_prop_fun({}); // ok
obj_prop_fun({p:{}}); // ok
obj_prop_fun({p:{q:null}}); // ok, provides add'l lower bound

function obj_prop_var(o={p:{q:""}}) {
  var {p:{q=0}={q:true}} = o;
  // errors:
  // * number  ~> void, from default on o.p.q
  // * boolean ~> void, from default on o.p
  // * string  ~> void, from default on o
  // * null    ~> void, from call below
  (q:void);
}
obj_prop_var(); // ok
obj_prop_var({}); // ok
obj_prop_var({p:{}}); // ok
obj_prop_var({p:{q:null}}); // ok, provides add'l lower bound

function obj_rest({p:{q,...o}={q:0,r:0}}={p:{q:0,r:""}}) {
  // errors:
  // * number  ~> void, from default on _.p
  // * string  ~> void, from default on _
  // * null    ~> void, from call below
  (o.r:void);
}
obj_rest(); // ok
obj_rest({}); // ok
obj_rest({p:{}}); // ok
obj_rest({p:{q:0,r:null}});

function obj_prop_annot({
  p = true // error: boolean ~> string
}: {
  p: string
} = {
  p: 0 // error: number ~> string
}) {
  (p:void); // error: string ~> void
}

var {
  p = true // error: boolean ~> string
}: {
  p: string
} = {
  p: 0 // error: number ~> string
};
(p:void); // error: string ~> void

function obj_prop_err({x:{y}}=null) {} // error: property \`x\` cannot be accessed on null
function obj_rest_err({...o}=0) {} // error: expected object instead of number
function arr_elem_err([x]=null) {} // error: element 0 cannot be accessed on null
function arr_rest_err([...a]=null) {} // error: expected array instead of null

function gen<T>(x:T,{p=x}:{p:T}):T {
  return p;
}

// Default values in destructuring unwrap optional types
obj_prop_fun(({} : {p?:{q?:null}})); // ok
obj_prop_var(({} : {p?:{q?:null}})); // ok

// union-like upper bounds preserved through destructuring
function obj_prop_opt({p}:{p?:string}={p:0}) {}
function obj_prop_maybe({p}:{p:?string}={p:0}) {}
function obj_prop_union({p}:{p:number|string}={p:true}) {}

// union-of-objects upper bounds preserved through destructuring
function obj_prop_union2({p}:{p:number}|{p:string}={p:true}) {}

function default_expr_scope({a, b = a}) {}

=====================================output=====================================
/* @flow */

function obj_prop_fun({ p: { q = 0 } = { q: true } } = { p: { q: "" } }) {
  // errors:
  // * number  ~> void, from default on _.p.q
  // * boolean ~> void, from default on _.p
  // * string  ~> void, from default on _
  // * null    ~> void, from call below
  (q: void);
}
obj_prop_fun(); // ok
obj_prop_fun({}); // ok
obj_prop_fun({ p: {} }); // ok
obj_prop_fun({ p: { q: null } }); // ok, provides add'l lower bound

function obj_prop_var(o = { p: { q: "" } }) {
  var { p: { q = 0 } = { q: true } } = o;
  // errors:
  // * number  ~> void, from default on o.p.q
  // * boolean ~> void, from default on o.p
  // * string  ~> void, from default on o
  // * null    ~> void, from call below
  (q: void);
}
obj_prop_var(); // ok
obj_prop_var({}); // ok
obj_prop_var({ p: {} }); // ok
obj_prop_var({ p: { q: null } }); // ok, provides add'l lower bound

function obj_rest(
  { p: { q, ...o } = { q: 0, r: 0 } } = { p: { q: 0, r: "" } }
) {
  // errors:
  // * number  ~> void, from default on _.p
  // * string  ~> void, from default on _
  // * null    ~> void, from call below
  (o.r: void);
}
obj_rest(); // ok
obj_rest({}); // ok
obj_rest({ p: {} }); // ok
obj_rest({ p: { q: 0, r: null } });

function obj_prop_annot(
  {
    p = true, // error: boolean ~> string
  }: {
    p: string,
  } = {
    p: 0, // error: number ~> string
  }
) {
  (p: void); // error: string ~> void
}

var {
  p = true, // error: boolean ~> string
}: {
  p: string,
} = {
  p: 0, // error: number ~> string
};
(p: void); // error: string ~> void

function obj_prop_err({ x: { y } } = null) {} // error: property \`x\` cannot be accessed on null
function obj_rest_err({ ...o } = 0) {} // error: expected object instead of number
function arr_elem_err([x] = null) {} // error: element 0 cannot be accessed on null
function arr_rest_err([...a] = null) {} // error: expected array instead of null

function gen<T>(x: T, { p = x }: { p: T }): T {
  return p;
}

// Default values in destructuring unwrap optional types
obj_prop_fun(({}: { p?: { q?: null } })); // ok
obj_prop_var(({}: { p?: { q?: null } })); // ok

// union-like upper bounds preserved through destructuring
function obj_prop_opt({ p }: { p?: string } = { p: 0 }) {}
function obj_prop_maybe({ p }: { p: ?string } = { p: 0 }) {}
function obj_prop_union({ p }: { p: number | string } = { p: true }) {}

// union-of-objects upper bounds preserved through destructuring
function obj_prop_union2({ p }: { p: number } | { p: string } = { p: true }) {}

function default_expr_scope({ a, b = a }) {}

================================================================================
`;

exports[`destructuring.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
declare var a:string;
declare var b:string;
declare var c:string;
[{a1:a, b},c] = [{a1:0, b:1},2];

var {m} = {m:0};
({m} = {m:m});

var obj;
({n: obj.x} = {n:3});
[obj.x] = ['foo'];

function foo({p, z:[r]}) {
    a = p;
    b = z;
    c = r;
}
foo({p:0, z:[1,2]});

[a,,b,...c] = [0,1,true,3];

function bar({x, ...z}) {
    var o:{x: string; y: number;} = z;
}
bar({x:"",y:0});

var spread = {y:""};
var extend: {x:number; y:string; z: boolean} = {x:0, ...spread};

function qux(_: {a:number}) { }
qux({a:""});
function corge({b}: {b:string}) { }
corge({b:0});

var {n}:{n: number} = {n: ""}

function test() {
  var {foo} = {bar: 123}; // error on foo
  var {bar, baz} = {bar: 123} // error on baz
}

function test() {
  var x = {foo: 'abc', bar: 123};
  var {foo, ...rest} = x;
  (x.baz: string); // error, baz doesn't exist
  (rest.baz: string); // error, rest is sealed
}

module.exports = corge;

class Base {
  baseprop1: number;
  baseprop2: number;
}

class Child extends Base {
  childprop1: number;
  childprop2: number;
}

var {baseprop1, childprop1, ...others} = new Child();

var bp1: number = baseprop1;
var bp1_err: string = baseprop1; // Error: number ~> string
var bp2: number = others.baseprop2;
var bp2_err: string = others.baseprop2; // Error: number ~> string

var cp1: number = childprop1;
var cp1_err: string = childprop1; // Error: number ~> string
var cp2: number = others.childprop1;
var cp2_err: string = others.childprop2; // Error: number ~> string

=====================================output=====================================
declare var a: string;
declare var b: string;
declare var c: string;
[{ a1: a, b }, c] = [{ a1: 0, b: 1 }, 2];

var { m } = { m: 0 };
({ m } = { m: m });

var obj;
({ n: obj.x } = { n: 3 });
[obj.x] = ["foo"];

function foo({ p, z: [r] }) {
  a = p;
  b = z;
  c = r;
}
foo({ p: 0, z: [1, 2] });

[a, , b, ...c] = [0, 1, true, 3];

function bar({ x, ...z }) {
  var o: { x: string, y: number } = z;
}
bar({ x: "", y: 0 });

var spread = { y: "" };
var extend: { x: number, y: string, z: boolean } = { x: 0, ...spread };

function qux(_: { a: number }) {}
qux({ a: "" });
function corge({ b }: { b: string }) {}
corge({ b: 0 });

var { n }: { n: number } = { n: "" };

function test() {
  var { foo } = { bar: 123 }; // error on foo
  var { bar, baz } = { bar: 123 }; // error on baz
}

function test() {
  var x = { foo: "abc", bar: 123 };
  var { foo, ...rest } = x;
  (x.baz: string); // error, baz doesn't exist
  (rest.baz: string); // error, rest is sealed
}

module.exports = corge;

class Base {
  baseprop1: number;
  baseprop2: number;
}

class Child extends Base {
  childprop1: number;
  childprop2: number;
}

var { baseprop1, childprop1, ...others } = new Child();

var bp1: number = baseprop1;
var bp1_err: string = baseprop1; // Error: number ~> string
var bp2: number = others.baseprop2;
var bp2_err: string = others.baseprop2; // Error: number ~> string

var cp1: number = childprop1;
var cp1_err: string = childprop1; // Error: number ~> string
var cp2: number = others.childprop1;
var cp2_err: string = others.childprop2; // Error: number ~> string

================================================================================
`;

exports[`destructuring_missing_props.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
//@flow
declare var x: {| foo: string |};
var {nonExistent, defaults = "hi", foo = 3} = x; // Error, missing nonExistent
(defaults: string);
(foo: number); // Error, number | string
(foo: number | string);

declare var y: {| bar: string |};
var {nonExistent2, defaults2 = "hi", bar = 3} = y; // Error, missing nonExistent2
(defaults2: string);
(bar: string); // Error, number | string
(bar: number | string);

var { baz = 15150 } = null // Error, baz is missing in null (you can't destructure null)

declare var z : { thud : string };
var { grunt = 15210 } = z; // Error, grunt missing in inexact object type

const proto : {| foo : number |} = { foo : 3 };
const obj = { __proto__ : proto, baz : "string" };
var { qux = "string" } = obj; // Error, qux missing

// Begin React examples

const React = require('react');
function Component({defaultProps = "default", regularProp}) { // Error, missing regularProp
  (defaultProps: string);
  (regularProp: number);
  return null;
}

const _a = <Component regularProp={3} />;
const _b = <Component />;

class A {
  prop: boolean;
  // No err! prop will always be initialized to a boolean
  constructor({prop = false}: {| prop: boolean |} = {}) {
  }
}

=====================================output=====================================
//@flow
declare var x: {| foo: string |};
var { nonExistent, defaults = "hi", foo = 3 } = x; // Error, missing nonExistent
(defaults: string);
(foo: number); // Error, number | string
(foo: number | string);

declare var y: {| bar: string |};
var { nonExistent2, defaults2 = "hi", bar = 3 } = y; // Error, missing nonExistent2
(defaults2: string);
(bar: string); // Error, number | string
(bar: number | string);

var { baz = 15150 } = null; // Error, baz is missing in null (you can't destructure null)

declare var z: { thud: string };
var { grunt = 15210 } = z; // Error, grunt missing in inexact object type

const proto: {| foo: number |} = { foo: 3 };
const obj = { __proto__: proto, baz: "string" };
var { qux = "string" } = obj; // Error, qux missing

// Begin React examples

const React = require("react");
function Component({ defaultProps = "default", regularProp }) {
  // Error, missing regularProp
  (defaultProps: string);
  (regularProp: number);
  return null;
}

const _a = <Component regularProp={3} />;
const _b = <Component />;

class A {
  prop: boolean;
  // No err! prop will always be initialized to a boolean
  constructor({ prop = false }: {| prop: boolean |} = {}) {}
}

================================================================================
`;

exports[`eager.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
var x;
({x} = null); // error, property \`x\` can not be accessed on \`null\`

=====================================output=====================================
var x;
({ x } = null); // error, property \`x\` can not be accessed on \`null\`

================================================================================
`;

exports[`object_rest.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
type O1 = { p: number, q: number }
declare var o1: O1;
var {p, ...o1_rest} = o1;
(o1_rest: { q: number }); // ok
o1_rest.x = 0; // error: rest result is sealed

type O2 = {| p: number, q: number |}
declare var o2: O2;
var {p, ...o2_rest} = o2;
(o2_rest: {| q: number|}); // ok
o2_rest.x = 0; // error: rest result is sealed

var o3 = { p: 0, q: 0 };
var {p, ...o3_rest} = o3;
(o3_rest: {| q: number |}); // ok
o3_rest.x = 0; // error: rest result is sealed

var o4 = {};
var {x, ...o4_rest} = o4;
// writes to the rest result do not reach reads from unsealed o4
(x: string); // ok, shadow read from unsealed o4
o4_rest.x = 0; // ok, rest result is unsealed

=====================================output=====================================
type O1 = { p: number, q: number };
declare var o1: O1;
var { p, ...o1_rest } = o1;
(o1_rest: { q: number }); // ok
o1_rest.x = 0; // error: rest result is sealed

type O2 = {| p: number, q: number |};
declare var o2: O2;
var { p, ...o2_rest } = o2;
(o2_rest: {| q: number |}); // ok
o2_rest.x = 0; // error: rest result is sealed

var o3 = { p: 0, q: 0 };
var { p, ...o3_rest } = o3;
(o3_rest: {| q: number |}); // ok
o3_rest.x = 0; // error: rest result is sealed

var o4 = {};
var { x, ...o4_rest } = o4;
// writes to the rest result do not reach reads from unsealed o4
(x: string); // ok, shadow read from unsealed o4
o4_rest.x = 0; // ok, rest result is unsealed

================================================================================
`;

exports[`poly.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

function obj_pattern<X>({ prop } : { prop: X }) {} // prop: X
type Prop<X> = { prop: X };
function obj_pattern2<X>({ prop } : Prop<X>) {} // prop: X

function arr_pattern<X>([ elem ] : X[]) {} // elem: X
type Elem<X> = X[];
function arr_pattern2<X>([ elem ] : Elem<X>) {} // elem: X

function tup_pattern<X>([ proj ] : [X]) {} // proj: X
type Proj<X> = [X];
function tup_pattern2<X>([ proj ] : Proj<X>) {} // proj: X

function rest_pattern<X>(...r: X[]) {} // r: X[]

function obj_rest_pattern<X>({ _, ...o } : { _: any, x: X }) { // o: { x: X }
  o.x;
}
type ObjRest<X> = { _: any, x: X };
function obj_rest_pattern<X>({ _, ...o } : ObjRest<X>) { // o: { x: X }
  o.x;
}

function arr_rest_pattern<X>([ _, ...a ] : [ any, X ]) { // a: [X]
  a[0];
}
type ArrRest<X> = [ any, X ];
function arr_rest_pattern<X>([ _, ...a ] : ArrRest<X>) { // a: [X]
  a[0];
}

=====================================output=====================================
// @flow

function obj_pattern<X>({ prop }: { prop: X }) {} // prop: X
type Prop<X> = { prop: X };
function obj_pattern2<X>({ prop }: Prop<X>) {} // prop: X

function arr_pattern<X>([elem]: X[]) {} // elem: X
type Elem<X> = X[];
function arr_pattern2<X>([elem]: Elem<X>) {} // elem: X

function tup_pattern<X>([proj]: [X]) {} // proj: X
type Proj<X> = [X];
function tup_pattern2<X>([proj]: Proj<X>) {} // proj: X

function rest_pattern<X>(...r: X[]) {} // r: X[]

function obj_rest_pattern<X>({ _, ...o }: { _: any, x: X }) {
  // o: { x: X }
  o.x;
}
type ObjRest<X> = { _: any, x: X };
function obj_rest_pattern<X>({ _, ...o }: ObjRest<X>) {
  // o: { x: X }
  o.x;
}

function arr_rest_pattern<X>([_, ...a]: [any, X]) {
  // a: [X]
  a[0];
}
type ArrRest<X> = [any, X];
function arr_rest_pattern<X>([_, ...a]: ArrRest<X>) {
  // a: [X]
  a[0];
}

================================================================================
`;

exports[`rec.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

// Make sure that destructuring doesn't cause infinite loops when combined with
// funny doses of repositioning

let foo = (i: number) => [i];

const bar = (i: number) => {
  [i] = foo(i);
  return [i];
};

foo = (i: number) => {
  return bar(i);
};

// Also make sure that the following doesn't loop

declare var o;
var { x: o } = o;

=====================================output=====================================
// @flow

// Make sure that destructuring doesn't cause infinite loops when combined with
// funny doses of repositioning

let foo = (i: number) => [i];

const bar = (i: number) => {
  [i] = foo(i);
  return [i];
};

foo = (i: number) => {
  return bar(i);
};

// Also make sure that the following doesn't loop

declare var o;
var { x: o } = o;

================================================================================
`;

exports[`refinement_non_termination.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

function _([argArray]: Array<Value>) {
  if (argArray instanceof NullValue || argArray instanceof UndefinedValue) {
  }
};

class Value { }
class NullValue extends Value { }
class UndefinedValue extends Value { }

=====================================output=====================================
// @flow

function _([argArray]: Array<Value>) {
  if (argArray instanceof NullValue || argArray instanceof UndefinedValue) {
  }
}

class Value {}
class NullValue extends Value {}
class UndefinedValue extends Value {}

================================================================================
`;

exports[`string_lit.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
var { "key": val } = { key: "val" };
(val: void); // error: string ~> void

var { "with-dash": with_dash } = { "with-dash": "motivating example" };
(with_dash: "motivating example"); // ok

=====================================output=====================================
var { key: val } = { key: "val" };
(val: void); // error: string ~> void

var { "with-dash": with_dash } = { "with-dash": "motivating example" };
(with_dash: "motivating example"); // ok

================================================================================
`;

exports[`unannotated.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

var { x } = {
  x: { foo: "foo" }
};

function bar() {
  x.bar
}

=====================================output=====================================
// @flow

var { x } = {
  x: { foo: "foo" },
};

function bar() {
  x.bar;
}

================================================================================
`;
