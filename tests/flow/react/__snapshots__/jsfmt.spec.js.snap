// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`ArityError.react.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/**
 * @providesModule ArityError.react
 */
var React = require('react');
var AudienceInsightsContainer = React.createClass({
  renderComponent(AudienceInsights: Class<React.Component<*, *>>) {
    return <AudienceInsights />;
  },
});

module.exports = AudienceInsightsContainer;

=====================================output=====================================
/**
 * @providesModule ArityError.react
 */
var React = require("react");
var AudienceInsightsContainer = React.createClass({
  renderComponent(AudienceInsights: Class<React.Component<*, *>>) {
    return <AudienceInsights />;
  },
});

module.exports = AudienceInsightsContainer;

================================================================================
`;

exports[`ConcurrentMode.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

import React from 'react';

{
  const {ConcurrentMode} = React;

  <ConcurrentMode>
    <div />
  </ConcurrentMode>
}

{
  const {Component, ConcurrentMode} = React;

  class ClassExample extends Component<{||}> {
    render() {
      return null;
    }
  }

  <ConcurrentMode>
    <ClassExample />
  </ConcurrentMode>
}

{
  const {ConcurrentMode} = React;

  function FunctionExample() {
    return null;
  }

  <ConcurrentMode>
    <FunctionExample />
  </ConcurrentMode>
}

=====================================output=====================================
// @flow

import React from "react";

{
  const { ConcurrentMode } = React;

  <ConcurrentMode>
    <div />
  </ConcurrentMode>;
}

{
  const { Component, ConcurrentMode } = React;

  class ClassExample extends Component<{||}> {
    render() {
      return null;
    }
  }

  <ConcurrentMode>
    <ClassExample />
  </ConcurrentMode>;
}

{
  const { ConcurrentMode } = React;

  function FunctionExample() {
    return null;
  }

  <ConcurrentMode>
    <FunctionExample />
  </ConcurrentMode>;
}

================================================================================
`;

exports[`StrictMode.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

import React from 'react';

{
  const {StrictMode} = React;

  <StrictMode>
    <div />
  </StrictMode>
}

{
  const {Component, StrictMode} = React;

  class ClassExample extends Component<{||}> {
    render() {
      return null;
    }
  }

  <StrictMode>
    <ClassExample />
  </StrictMode>
}

{
  const {StrictMode} = React;

  function FunctionExample() {
    return null;
  }

  <StrictMode>
    <FunctionExample />
  </StrictMode>
}

=====================================output=====================================
// @flow

import React from "react";

{
  const { StrictMode } = React;

  <StrictMode>
    <div />
  </StrictMode>;
}

{
  const { Component, StrictMode } = React;

  class ClassExample extends Component<{||}> {
    render() {
      return null;
    }
  }

  <StrictMode>
    <ClassExample />
  </StrictMode>;
}

{
  const { StrictMode } = React;

  function FunctionExample() {
    return null;
  }

  <StrictMode>
    <FunctionExample />
  </StrictMode>;
}

================================================================================
`;

exports[`abstractelement.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
//@flow

const React = require('react');

type Props1 = {  a : number  }
type Props2 = {| b : string |}

class Component1 extends React.Component<Props1>{}
class Component2 extends React.Component<Props2>{}

function takesTop(e : React.MixedElement) {
  (e.props : mixed);
  e.props.a; // error
}

takesTop(<Component1 a={1}/>);
takesTop(<Component2 b={"B"}/>);
takesTop(<div/>)

function takesAny(e : React$Element<any>) {
  (e.props : mixed);
  e.props.a;
}

takesAny(<Component1 a={1}/>);
takesAny(<Component2 b={"B"}/>);
takesAny(<div/>)

=====================================output=====================================
//@flow

const React = require("react");

type Props1 = { a: number };
type Props2 = {| b: string |};

class Component1 extends React.Component<Props1> {}
class Component2 extends React.Component<Props2> {}

function takesTop(e: React.MixedElement) {
  (e.props: mixed);
  e.props.a; // error
}

takesTop(<Component1 a={1} />);
takesTop(<Component2 b={"B"} />);
takesTop(<div />);

function takesAny(e: React$Element<any>) {
  (e.props: mixed);
  e.props.a;
}

takesAny(<Component1 a={1} />);
takesAny(<Component2 b={"B"} />);
takesAny(<div />);

================================================================================
`;

exports[`creatRef.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

import React from 'react';

{
  class MyComponent extends React.Component<void> {}

  const ref: {current: null | React$ComponentType<MyComponent>} = React.createRef(); // Ok
}

{
  const ref: {|current: null | number|} = React.createRef(); // Ok
}

=====================================output=====================================
// @flow

import React from "react";

{
  class MyComponent extends React.Component<void> {}

  const ref: {
    current: null | React$ComponentType<MyComponent>,
  } = React.createRef(); // Ok
}

{
  const ref: {| current: null | number |} = React.createRef(); // Ok
}

================================================================================
`;

exports[`create_class.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
import React from "react";

const A = React.createClass({
  mixins: [{ propTypes: { foo: React.PropTypes.string.isRequired } }],
  propTypes: { bar: React.PropTypes.number.isRequired },
  m() {
    (this.props.foo: empty); // error: string ~> empty
    (this.props.bar: empty); // error: number ~> empty
  }
});

const B = React.createClass({
  p: "",
  m() {
    this.p = 0; // error: number ~> string
  },
  mm() {
    this.m.apply(null); // OK: this.m is autobound, so \`this.p\` will always be found
  }
});

const C = React.createClass({
  getInitialState(): Object {
    return { foo: 0 };
  },
  m() {
    this.state.foo; // OK: state is unknown
  }
});

const D = React.createClass({
  mixins: [{
    getInitialState(): Object {
      return { foo: 0 };
    },
  }],
  getInitialState() {
    return { bar: 0 };
  },
  m() {
    this.state.foo; // OK: state is unknown (due to unknown mixin)
  }
});

const E = React.createClass({
  foo: 0,
  m() {
    (this.foo: string); // error: number ~> string
  },
  mm() {
    var props: { m(): void } = { m: this.m };
    props.m(); // OK: this.m is autobound, so \`this.foo\` will always be found
  }
});

const F = React.createClass({
  getInitialState(): { [string]: mixed } {
    return { foo: 0 };
  },
  m() {
    this.state.foo;
    this.state.bar;
  },
});

const G = React.createClass({
  mixins: [],
  autobind: true,
  statics: {},
  m() {
    (this.mixins: mixed); // error: property \`mixins\` not found
    (this.autobind: mixed); // error: property \`autobind\` not found
    (this.statics: mixed); // error: property \`statics\` not found
  },
});

const H = React.createClass({
  statics: { q: 0 },
  getDefaultProps() {
    (this.q: empty); // error: number ~> empty
    return {};
  },
});

const I = React.createClass({
  propTypes: ({}: {[string]: any}),
  m() {
    (this.props.foo: empty); // OK
  }
});

const J = React.createClass({
  mixins: [{
    getInitialState() {
      return this.constructor.calculateState();
    },
  }],
  statics: {
    calculateState() {
      return { foo: 0 };
    },
  },
  m() {
    (this.state.foo: empty); // number ~> empty
  },
});

const K = React.createClass({
  propTypes: {
    foo: React.PropTypes.string.isRequired,
  },
  getInitialState() {
    this.mm(); // cause error in mm below
    return this.props;
  },
  m() {
    (this.props.foo: empty); // string ~> empty
    (this.state.foo: empty); // string ~> empty
  },
  mm() {
    this.state.foo; // error: property fo not found (called by getInitialState)
  }
});

const L = React.createClass({
  propTypes: {
    foo: React.PropTypes.string.isRequired,
  },
  getInitialState() {
    return { bar: 0 };
  },
  componentWillMount() {
    (this.props.foo: empty); // string ~> empty
    return 0; // number ~> mixed
  },
  componentDidMount() {
    (this.props.foo: empty); // string ~> empty
    return 0; // number ~> mixed
  },
  componentWillReceiveProps(nextProps) {
    (this.props.foo: empty); // string ~> empty
    (nextProps.foo: empty); // string ~> empty
    return 0; // number ~> mixed
  },
  shouldComponentUpdate(nextProps, nextState) {
    (this.props.foo: empty); // string ~> empty
    (this.state.bar: empty); // number ~> empty
    (nextProps.foo: empty); // string ~> empty
    (nextState.bar: empty); // number ~> empty
    return 0; // number ~> bool
  },
  componentWillUpdate(nextProps, nextState) {
    (this.props.foo: empty); // string ~> empty
    (this.state.bar: empty); // number ~> empty
    (nextProps.foo: empty); // string ~> empty
    (nextState.bar: empty); // number ~> empty
    return 0; // number ~> void
  },
  componentDidUpdate(nextProps, nextState) {
    (this.props.foo: empty); // string ~> empty
    (this.state.bar: empty); // number ~> empty
    (nextProps.foo: empty); // string ~> empty
    (nextState.bar: empty); // number ~> empty
    return 0; // number ~> void
  },
  componentWillUnmount() {
    (this.props.foo: empty); // string ~> empty
    (this.state.bar: empty); // number ~> empty
    return 0; // number ~> void
  },
});

React.createClass({}); // error: spec must be [x] exact and [ ] sealed
React.createClass(({}: {})); // error: spec must be [ ] exact and [x] sealed

const M = React.createClass({
  propTypes: {
    foo: React.PropTypes.string,
  },
});
M.defaultProps.bar = 1; // error cannot update void property

=====================================output=====================================
import React from "react";

const A = React.createClass({
  mixins: [{ propTypes: { foo: React.PropTypes.string.isRequired } }],
  propTypes: { bar: React.PropTypes.number.isRequired },
  m() {
    (this.props.foo: empty); // error: string ~> empty
    (this.props.bar: empty); // error: number ~> empty
  },
});

const B = React.createClass({
  p: "",
  m() {
    this.p = 0; // error: number ~> string
  },
  mm() {
    this.m.apply(null); // OK: this.m is autobound, so \`this.p\` will always be found
  },
});

const C = React.createClass({
  getInitialState(): Object {
    return { foo: 0 };
  },
  m() {
    this.state.foo; // OK: state is unknown
  },
});

const D = React.createClass({
  mixins: [
    {
      getInitialState(): Object {
        return { foo: 0 };
      },
    },
  ],
  getInitialState() {
    return { bar: 0 };
  },
  m() {
    this.state.foo; // OK: state is unknown (due to unknown mixin)
  },
});

const E = React.createClass({
  foo: 0,
  m() {
    (this.foo: string); // error: number ~> string
  },
  mm() {
    var props: { m(): void } = { m: this.m };
    props.m(); // OK: this.m is autobound, so \`this.foo\` will always be found
  },
});

const F = React.createClass({
  getInitialState(): { [string]: mixed } {
    return { foo: 0 };
  },
  m() {
    this.state.foo;
    this.state.bar;
  },
});

const G = React.createClass({
  mixins: [],
  autobind: true,
  statics: {},
  m() {
    (this.mixins: mixed); // error: property \`mixins\` not found
    (this.autobind: mixed); // error: property \`autobind\` not found
    (this.statics: mixed); // error: property \`statics\` not found
  },
});

const H = React.createClass({
  statics: { q: 0 },
  getDefaultProps() {
    (this.q: empty); // error: number ~> empty
    return {};
  },
});

const I = React.createClass({
  propTypes: ({}: { [string]: any }),
  m() {
    (this.props.foo: empty); // OK
  },
});

const J = React.createClass({
  mixins: [
    {
      getInitialState() {
        return this.constructor.calculateState();
      },
    },
  ],
  statics: {
    calculateState() {
      return { foo: 0 };
    },
  },
  m() {
    (this.state.foo: empty); // number ~> empty
  },
});

const K = React.createClass({
  propTypes: {
    foo: React.PropTypes.string.isRequired,
  },
  getInitialState() {
    this.mm(); // cause error in mm below
    return this.props;
  },
  m() {
    (this.props.foo: empty); // string ~> empty
    (this.state.foo: empty); // string ~> empty
  },
  mm() {
    this.state.foo; // error: property fo not found (called by getInitialState)
  },
});

const L = React.createClass({
  propTypes: {
    foo: React.PropTypes.string.isRequired,
  },
  getInitialState() {
    return { bar: 0 };
  },
  componentWillMount() {
    (this.props.foo: empty); // string ~> empty
    return 0; // number ~> mixed
  },
  componentDidMount() {
    (this.props.foo: empty); // string ~> empty
    return 0; // number ~> mixed
  },
  componentWillReceiveProps(nextProps) {
    (this.props.foo: empty); // string ~> empty
    (nextProps.foo: empty); // string ~> empty
    return 0; // number ~> mixed
  },
  shouldComponentUpdate(nextProps, nextState) {
    (this.props.foo: empty); // string ~> empty
    (this.state.bar: empty); // number ~> empty
    (nextProps.foo: empty); // string ~> empty
    (nextState.bar: empty); // number ~> empty
    return 0; // number ~> bool
  },
  componentWillUpdate(nextProps, nextState) {
    (this.props.foo: empty); // string ~> empty
    (this.state.bar: empty); // number ~> empty
    (nextProps.foo: empty); // string ~> empty
    (nextState.bar: empty); // number ~> empty
    return 0; // number ~> void
  },
  componentDidUpdate(nextProps, nextState) {
    (this.props.foo: empty); // string ~> empty
    (this.state.bar: empty); // number ~> empty
    (nextProps.foo: empty); // string ~> empty
    (nextState.bar: empty); // number ~> empty
    return 0; // number ~> void
  },
  componentWillUnmount() {
    (this.props.foo: empty); // string ~> empty
    (this.state.bar: empty); // number ~> empty
    return 0; // number ~> void
  },
});

React.createClass({}); // error: spec must be [x] exact and [ ] sealed
React.createClass(({}: {})); // error: spec must be [ ] exact and [x] sealed

const M = React.createClass({
  propTypes: {
    foo: React.PropTypes.string,
  },
});
M.defaultProps.bar = 1; // error cannot update void property

================================================================================
`;

exports[`create_class_initial_state_sealed.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
import React from "react";

// initial state = None
React.createClass({
  f() {
    this.setState({ q: 0 });
  },
  g() {
    (this.state.q: empty); // number ~> empty
  }
});

// initial state = Some (exact & sealed) [lit]
React.createClass({
  getInitialState() {
    return { p: 0 };
  },
  f() {
    this.setState({ q: 0 });
  },
  g() {
    (this.state.q: empty); // number ~> empty
  }
});

// initial state = Some (exact & sealed) [annot]
React.createClass({
  getInitialState(): {| p: number |} {
    return { p: 0 };
  },
  f() {
    this.setState({ q: 0 });
  },
  g() {
    (this.state.q: empty); // number ~> empty
  }
});

// initial state = Some (inexact & sealed) [annot]
React.createClass({
  getInitialState(): { p: number } {
    return { p: 0 };
  },
  f() {
    this.setState({ q: 0 }); // property \`q\` not found
  },
  g() {
    (this.state.q: empty); // property \`q\` not found
  }
});

// mixins = (exact & sealed) + (exact & sealed)
React.createClass({
  mixins: [{
    getInitialState() {
      return { foo: 0 };
    },
  }],
  getInitialState() {
    return { bar: 0 };
  },
  f() {
    this.setState({ baz: 0 });
  },
  g() {
    (this.state.baz: empty); // number ~> empty
  }
});

// mixins = (exact & sealed) + (inexact & sealed)
React.createClass({
  mixins: [{
    getInitialState(): { foo: number } {
      return { foo: 0 };
    },
  }],
  getInitialState() {
    return { bar: 0 };
  },
  f() {
    this.setState({ baz: 0 }); // property \`baz\`  not found
  },
  g() {
    (this.state.baz: empty); // property \`baz\` not found
  }
});

=====================================output=====================================
import React from "react";

// initial state = None
React.createClass({
  f() {
    this.setState({ q: 0 });
  },
  g() {
    (this.state.q: empty); // number ~> empty
  },
});

// initial state = Some (exact & sealed) [lit]
React.createClass({
  getInitialState() {
    return { p: 0 };
  },
  f() {
    this.setState({ q: 0 });
  },
  g() {
    (this.state.q: empty); // number ~> empty
  },
});

// initial state = Some (exact & sealed) [annot]
React.createClass({
  getInitialState(): {| p: number |} {
    return { p: 0 };
  },
  f() {
    this.setState({ q: 0 });
  },
  g() {
    (this.state.q: empty); // number ~> empty
  },
});

// initial state = Some (inexact & sealed) [annot]
React.createClass({
  getInitialState(): { p: number } {
    return { p: 0 };
  },
  f() {
    this.setState({ q: 0 }); // property \`q\` not found
  },
  g() {
    (this.state.q: empty); // property \`q\` not found
  },
});

// mixins = (exact & sealed) + (exact & sealed)
React.createClass({
  mixins: [
    {
      getInitialState() {
        return { foo: 0 };
      },
    },
  ],
  getInitialState() {
    return { bar: 0 };
  },
  f() {
    this.setState({ baz: 0 });
  },
  g() {
    (this.state.baz: empty); // number ~> empty
  },
});

// mixins = (exact & sealed) + (inexact & sealed)
React.createClass({
  mixins: [
    {
      getInitialState(): { foo: number } {
        return { foo: 0 };
      },
    },
  ],
  getInitialState() {
    return { bar: 0 };
  },
  f() {
    this.setState({ baz: 0 }); // property \`baz\`  not found
  },
  g() {
    (this.state.baz: empty); // property \`baz\` not found
  },
});

================================================================================
`;

exports[`create_class_statics_sealed.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
import React from "react";

// statics = None
const A = React.createClass({ p: 0 });
(A.bar: empty); // number ~> empty (inflow below)
A.bar = 0;

// statics = Some (exact & sealed) [lit]
const B = React.createClass({
  statics: { foo: 0 },
});
(B.foo: empty); // number ~> empty
(B.bar: empty); // number ~> empty (inflow below)
B.bar = 0;

// statics = Some (exact & sealed) [annot]
const C = React.createClass({
  statics: ({ foo: 0 }: {| foo: number |}),
});
(C.foo: empty); // number ~> empty
(C.bar: empty); // number ~> empty (inflow below)
C.bar = 0;

// statics = Some (inexact & sealed) [annot]
const D = React.createClass({
  statics: ({ foo: 0 }: { foo: number }),
});
(D.foo: empty); // number ~> empty
(D.bar: empty); // property \`bar\` not found
D.bar = 0; // property \`bar\` not found

// mixins: (exact & sealed) + (exact & sealed)
const E = React.createClass({
  mixins: [{
    statics: { foo: 0 },
  }],
  statics: { bar: 0 },
});
(E.foo: empty); // number ~> empty
(E.bar: empty); // number ~> empty
(E.baz: empty); // number ~> empty (inflow below)
E.baz = 0;

// mixins: (exact & sealed) + (inexact & sealed)
const F = React.createClass({
  mixins: [{
    statics: ({ foo: 0 }: { foo: number }),
  }],
  statics: { bar: 0 },
});
(F.foo: empty); // number ~> empty
(F.bar: empty); // number ~> empty
(F.baz: empty); // number ~> empty (inflow below)
F.baz = 0;

=====================================output=====================================
import React from "react";

// statics = None
const A = React.createClass({ p: 0 });
(A.bar: empty); // number ~> empty (inflow below)
A.bar = 0;

// statics = Some (exact & sealed) [lit]
const B = React.createClass({
  statics: { foo: 0 },
});
(B.foo: empty); // number ~> empty
(B.bar: empty); // number ~> empty (inflow below)
B.bar = 0;

// statics = Some (exact & sealed) [annot]
const C = React.createClass({
  statics: ({ foo: 0 }: {| foo: number |}),
});
(C.foo: empty); // number ~> empty
(C.bar: empty); // number ~> empty (inflow below)
C.bar = 0;

// statics = Some (inexact & sealed) [annot]
const D = React.createClass({
  statics: ({ foo: 0 }: { foo: number }),
});
(D.foo: empty); // number ~> empty
(D.bar: empty); // property \`bar\` not found
D.bar = 0; // property \`bar\` not found

// mixins: (exact & sealed) + (exact & sealed)
const E = React.createClass({
  mixins: [
    {
      statics: { foo: 0 },
    },
  ],
  statics: { bar: 0 },
});
(E.foo: empty); // number ~> empty
(E.bar: empty); // number ~> empty
(E.baz: empty); // number ~> empty (inflow below)
E.baz = 0;

// mixins: (exact & sealed) + (inexact & sealed)
const F = React.createClass({
  mixins: [
    {
      statics: ({ foo: 0 }: { foo: number }),
    },
  ],
  statics: { bar: 0 },
});
(F.foo: empty); // number ~> empty
(F.bar: empty); // number ~> empty
(F.baz: empty); // number ~> empty (inflow below)
F.baz = 0;

================================================================================
`;

exports[`create_class_super.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

const React = require("react");

const Base = React.createClass({
  render: () => null,
});

class Derived extends Base {
  render() { return null } // ok, Base#render is covariant
}

(<Derived />);

=====================================output=====================================
// @flow

const React = require("react");

const Base = React.createClass({
  render: () => null,
});

class Derived extends Base {
  render() {
    return null;
  } // ok, Base#render is covariant
}

<Derived />;

================================================================================
`;

exports[`createContext.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

import React from 'react';

{
  const Context = React.createContext('div');
  const {Consumer, Provider} = Context;

  class Foo extends React.Component<{}> {
    divRef: {current: null | HTMLDivElement} = React.createRef();

    render() {
      return (
        <React.Fragment>
          <Provider value='span'>
            <div ref={this.divRef}>
              <Consumer>
                {(Tag: 'div' | 'span' | 'img') => <Tag />}
              </Consumer>
            </div>
          </Provider>
          <Provider value='spam'> {/* Error: enum is incompatible with string */}
            <Consumer>
              {(Tag: 'div' | 'span' | 'img') => <Tag />}
            </Consumer>
          </Provider>
        </React.Fragment>
      );
    }

    componentDidMount() {
      var div: null | HTMLDivElement = this.divRef.current; // Ok
      var image: null | HTMLImageElement = this.divRef.current; // Error: HTMLDivElement is incompatible with HTMLImageElement
    }
  }
}

{
  const Context = React.createContext(
    {foo: 0, bar: 0, baz: 0},
    (a, b) => {
      let result = 0;
      if (a.foo !== b.foo) {
        result |= 0b001;
      }
      if (a.bar !== b.bar) {
        result |= 0b010;
      }
      return result;
    },
  );
}

{
  const ThemeContext = createContext("light");
  ThemeContext.displayName = "ThemeContext";
}

=====================================output=====================================
// @flow

import React from "react";

{
  const Context = React.createContext("div");
  const { Consumer, Provider } = Context;

  class Foo extends React.Component<{}> {
    divRef: { current: null | HTMLDivElement } = React.createRef();

    render() {
      return (
        <React.Fragment>
          <Provider value="span">
            <div ref={this.divRef}>
              <Consumer>{(Tag: "div" | "span" | "img") => <Tag />}</Consumer>
            </div>
          </Provider>
          <Provider value="spam">
            {" "}
            {/* Error: enum is incompatible with string */}
            <Consumer>{(Tag: "div" | "span" | "img") => <Tag />}</Consumer>
          </Provider>
        </React.Fragment>
      );
    }

    componentDidMount() {
      var div: null | HTMLDivElement = this.divRef.current; // Ok
      var image: null | HTMLImageElement = this.divRef.current; // Error: HTMLDivElement is incompatible with HTMLImageElement
    }
  }
}

{
  const Context = React.createContext({ foo: 0, bar: 0, baz: 0 }, (a, b) => {
    let result = 0;
    if (a.foo !== b.foo) {
      result |= 0b001;
    }
    if (a.bar !== b.bar) {
      result |= 0b010;
    }
    return result;
  });
}

{
  const ThemeContext = createContext("light");
  ThemeContext.displayName = "ThemeContext";
}

================================================================================
`;

exports[`createElement_string.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow
import React from 'react';

class Bar extends React.Component<{}> {}

class Foo extends React.Component<{}> {
  render() {
    const Cmp = Math.random() < 0.5 ? 'div' : Bar;
    return (<Cmp/>);
  }
}

=====================================output=====================================
// @flow
import React from "react";

class Bar extends React.Component<{}> {}

class Foo extends React.Component<{}> {
  render() {
    const Cmp = Math.random() < 0.5 ? "div" : Bar;
    return <Cmp />;
  }
}

================================================================================
`;

exports[`createElementRequiredProp_string.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow
import React from 'react';

class Bar extends React.Component<{test: number}> {
  render() {
    return (
      <div>
        {this.props.test}
      </div>
    )
  }
}

class Foo extends React.Component<{}> {
  render() {
    const Cmp = Math.random() < 0.5 ? 'div' : Bar;
    return (<Cmp/>);
  }
}

=====================================output=====================================
// @flow
import React from "react";

class Bar extends React.Component<{ test: number }> {
  render() {
    return <div>{this.props.test}</div>;
  }
}

class Foo extends React.Component<{}> {
  render() {
    const Cmp = Math.random() < 0.5 ? "div" : Bar;
    return <Cmp />;
  }
}

================================================================================
`;

exports[`default_props_any.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

import React from 'react';

class Foo extends React.Component<{required: number}> {
  static defaultProps: Object;
}

class Bar extends React.Component<{required: number}> {
  static defaultProps: any;
}

<Foo/>;
<Bar/>;

=====================================output=====================================
// @flow

import React from "react";

class Foo extends React.Component<{ required: number }> {
  static defaultProps: Object;
}

class Bar extends React.Component<{ required: number }> {
  static defaultProps: any;
}

<Foo />;
<Bar />;

================================================================================
`;

exports[`default_props_undefined.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

import React from 'react';

class Foo extends React.Component<{bar: number}, void> {
  static defaultProps = {bar: 42};
}

<Foo bar={42}/>; // OK
<Foo bar="42"/>; // Error
<Foo bar={undefined}/>; // OK: React will replace \`undefined\` with the default.

=====================================output=====================================
// @flow

import React from "react";

class Foo extends React.Component<{ bar: number }, void> {
  static defaultProps = { bar: 42 };
}

<Foo bar={42} />; // OK
<Foo bar="42" />; // Error
<Foo bar={undefined} />; // OK: React will replace \`undefined\` with the default.

================================================================================
`;

exports[`dotvsdollar.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
//@flow

// React.Element(Type) was behaving differently from React$Element(Type) due to a mishandled
// type destructor case. This tests that the logic stays correct, as all 8 of these should correctly
// typecheck.
const React = require('react');
class Component extends React.Component<{}> {};

declare var a : React.Element<Class<Component>>;
(a : React.Element<React.ElementType>);

const b = <Component/>;
(b: React.Element<React.ElementType>);

declare var c : React.Element<Class<Component>>;
(c : React.Element<React$ElementType>);

const d = <Component/>;
(d: React.Element<React$ElementType>);

declare var e : React.Element<Class<Component>>;
(d : React$Element<React$ElementType>);

const f = <Component/>;
(f: React$Element<React$ElementType>);

declare var g : React.Element<Class<Component>>;
(g : React$Element<React.ElementType>);

const h = <Component/>;
(h: React$Element<React.ElementType>);

=====================================output=====================================
//@flow

// React.Element(Type) was behaving differently from React$Element(Type) due to a mishandled
// type destructor case. This tests that the logic stays correct, as all 8 of these should correctly
// typecheck.
const React = require("react");
class Component extends React.Component<{}> {}

declare var a: React.Element<Class<Component>>;
(a: React.Element<React.ElementType>);

const b = <Component />;
(b: React.Element<React.ElementType>);

declare var c: React.Element<Class<Component>>;
(c: React.Element<React$ElementType>);

const d = <Component />;
(d: React.Element<React$ElementType>);

declare var e: React.Element<Class<Component>>;
(d: React$Element<React$ElementType>);

const f = <Component />;
(f: React$Element<React$ElementType>);

declare var g: React.Element<Class<Component>>;
(g: React$Element<React.ElementType>);

const h = <Component />;
(h: React$Element<React.ElementType>);

================================================================================
`;

exports[`element_config.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/**
 * @format
 * @flow
 */

import * as React from 'react';

declare var exactEmptyObject: {||};

class A extends React.Component<{p: ?number}> {
  static defaultProps = {p: 42}; // OK
}

class B extends React.Component<{p: ?number}> {
  static defaultProps = {p: 'foo'}; // Error: string ~> number
}

class C extends React.Component<{p: ?number}> {
  static defaultProps = ({}: {p?: number}); // OK
}

class D extends React.Component<{p: ?number}> {
  static defaultProps = ({}: {p?: string}); // OK
}

class E extends React.Component<{}> {
  static defaultProps = {p: 42}; // OK
}

class F extends React.Component<{||}> {
  static defaultProps = {p: 42}; // Error: extra property \`p\`
}

class G extends React.Component<{p: ?number}> {
  static defaultProps = {p: 42}; // OK
}

class H extends React.Component<{p?: ?number}> {
  static defaultProps = {p: 'foo'}; // Error: string ~> number
}

class I extends React.Component<{p?: ?number}> {
  static defaultProps = ({}: {p?: number}); // OK
}

class J extends React.Component<{p?: ?number}> {
  static defaultProps = ({}: {p?: string}); // Error: string ~> number
}

({}: React.ElementConfig<typeof A>); // OK
({p: 42}: React.ElementConfig<typeof A>); // OK
({p: 'foo'}: React.ElementConfig<typeof A>); // Error: string ~> number

({}: React.ElementConfig<typeof B>); // OK
({p: 42}: React.ElementConfig<typeof B>); // OK
({p: 'foo'}: React.ElementConfig<typeof B>); // Error: string ~> number

(({}: {}): React.ElementConfig<typeof C>); // Error: missing property \`p\`
({p: 42}: React.ElementConfig<typeof C>); // OK
({p: 'foo'}: React.ElementConfig<typeof C>); // Error: string ~> number

(({}: {}): React.ElementConfig<typeof D>); // Error: missing property \`p\`
({p: 42}: React.ElementConfig<typeof D>); // OK
({p: 'foo'}: React.ElementConfig<typeof D>); // Error: string ~> number

({}: React.ElementConfig<typeof E>); // OK
({p: 42}: React.ElementConfig<typeof E>); // OK
({p: 'foo'}: React.ElementConfig<typeof E>); // OK

(exactEmptyObject: React.ElementConfig<typeof F>); // OK
({p: 42}: React.ElementConfig<typeof F>); // Error: extra property \`p\`
({p: 'foo'}: React.ElementConfig<typeof F>); // Error: extra property \`p\`

({}: React.ElementConfig<typeof G>); // OK
({p: 42}: React.ElementConfig<typeof G>); // OK
({p: 'foo'}: React.ElementConfig<typeof G>); // Error: string ~> number

({}: React.ElementConfig<typeof H>); // OK
({p: 42}: React.ElementConfig<typeof H>); // OK
({p: 'foo'}: React.ElementConfig<typeof H>); // Error: string ~> number

({}: React.ElementConfig<typeof I>); // OK
({p: 42}: React.ElementConfig<typeof I>); // OK
({p: 'foo'}: React.ElementConfig<typeof I>); // Error: string ~> number

({}: React.ElementConfig<typeof J>); // OK
({p: 42}: React.ElementConfig<typeof J>); // OK
({p: 'foo'}: React.ElementConfig<typeof J>); // Error: string ~> number

=====================================output=====================================
/**
 * @format
 * @flow
 */

import * as React from "react";

declare var exactEmptyObject: {||};

class A extends React.Component<{ p: ?number }> {
  static defaultProps = { p: 42 }; // OK
}

class B extends React.Component<{ p: ?number }> {
  static defaultProps = { p: "foo" }; // Error: string ~> number
}

class C extends React.Component<{ p: ?number }> {
  static defaultProps = ({}: { p?: number }); // OK
}

class D extends React.Component<{ p: ?number }> {
  static defaultProps = ({}: { p?: string }); // OK
}

class E extends React.Component<{}> {
  static defaultProps = { p: 42 }; // OK
}

class F extends React.Component<{||}> {
  static defaultProps = { p: 42 }; // Error: extra property \`p\`
}

class G extends React.Component<{ p: ?number }> {
  static defaultProps = { p: 42 }; // OK
}

class H extends React.Component<{ p?: ?number }> {
  static defaultProps = { p: "foo" }; // Error: string ~> number
}

class I extends React.Component<{ p?: ?number }> {
  static defaultProps = ({}: { p?: number }); // OK
}

class J extends React.Component<{ p?: ?number }> {
  static defaultProps = ({}: { p?: string }); // Error: string ~> number
}

({}: React.ElementConfig<typeof A>); // OK
({ p: 42 }: React.ElementConfig<typeof A>); // OK
({ p: "foo" }: React.ElementConfig<typeof A>); // Error: string ~> number

({}: React.ElementConfig<typeof B>); // OK
({ p: 42 }: React.ElementConfig<typeof B>); // OK
({ p: "foo" }: React.ElementConfig<typeof B>); // Error: string ~> number

(({}: {}): React.ElementConfig<typeof C>); // Error: missing property \`p\`
({ p: 42 }: React.ElementConfig<typeof C>); // OK
({ p: "foo" }: React.ElementConfig<typeof C>); // Error: string ~> number

(({}: {}): React.ElementConfig<typeof D>); // Error: missing property \`p\`
({ p: 42 }: React.ElementConfig<typeof D>); // OK
({ p: "foo" }: React.ElementConfig<typeof D>); // Error: string ~> number

({}: React.ElementConfig<typeof E>); // OK
({ p: 42 }: React.ElementConfig<typeof E>); // OK
({ p: "foo" }: React.ElementConfig<typeof E>); // OK

(exactEmptyObject: React.ElementConfig<typeof F>); // OK
({ p: 42 }: React.ElementConfig<typeof F>); // Error: extra property \`p\`
({ p: "foo" }: React.ElementConfig<typeof F>); // Error: extra property \`p\`

({}: React.ElementConfig<typeof G>); // OK
({ p: 42 }: React.ElementConfig<typeof G>); // OK
({ p: "foo" }: React.ElementConfig<typeof G>); // Error: string ~> number

({}: React.ElementConfig<typeof H>); // OK
({ p: 42 }: React.ElementConfig<typeof H>); // OK
({ p: "foo" }: React.ElementConfig<typeof H>); // Error: string ~> number

({}: React.ElementConfig<typeof I>); // OK
({ p: 42 }: React.ElementConfig<typeof I>); // OK
({ p: "foo" }: React.ElementConfig<typeof I>); // Error: string ~> number

({}: React.ElementConfig<typeof J>); // OK
({ p: 42 }: React.ElementConfig<typeof J>); // OK
({ p: "foo" }: React.ElementConfig<typeof J>); // Error: string ~> number

================================================================================
`;

exports[`element_with_component_type.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

const React = require('react');

class Foo extends React.Component<{a: number}> {}

(<Foo a={42}/>: React.Element<React.ComponentType<{a: number}>>); // OK
(<Foo a={42}/>: React.Element<React.ComponentType<{b: number}>>); // Error

=====================================output=====================================
// @flow

const React = require("react");

class Foo extends React.Component<{ a: number }> {}

(<Foo a={42} />: React.Element<React.ComponentType<{ a: number }>>); // OK
(<Foo a={42} />: React.Element<React.ComponentType<{ b: number }>>); // Error

================================================================================
`;

exports[`hoc.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

import React from 'react';

function myHOC(
  Component: React$ComponentType<{foo: number, bar: number}>,
): React$ComponentType<{foo: number}> {
  return class extends React.Component<{foo: number}, {bar: number}> {
    state = {bar: 2};
    render() {
      <Component />; // Error: \`foo\` is required.
      <Component foo={42} />; // Error: \`bar\` is required.
      <Component foo={1} bar={2} />; // OK
      return <Component foo={this.props.foo} bar={this.state.bar}/>;
    }
  }
}

class Unwrapped extends React.Component<{
  foo: number,
  bar: number,
}, {
  buz: number,
}> {
  state = {buz: 3};
  render() {
    return this.props.foo + this.props.bar + this.state.buz;
  }
}

function UnwrappedFun(props: {foo: number, bar: number}) {
  return props.foo + props.bar;
}

myHOC(class Empty extends React.Component<{foo: string}, void> {}); // Error
myHOC(function Empty(props: {foo: string}) {}); // Error

const Wrapped: React$ComponentType<{foo: number}> = myHOC(Unwrapped);
const WrappedFun = myHOC(UnwrappedFun);

<Wrapped nonsense="what" />; // Error: \`foo\` is required.
<Wrapped foo={1} />; // OK
<WrappedFun />; // Error: \`foo\` is required.
<WrappedFun foo={1}/>; // OK

=====================================output=====================================
// @flow

import React from "react";

function myHOC(
  Component: React$ComponentType<{ foo: number, bar: number }>
): React$ComponentType<{ foo: number }> {
  return class extends React.Component<{ foo: number }, { bar: number }> {
    state = { bar: 2 };
    render() {
      <Component />; // Error: \`foo\` is required.
      <Component foo={42} />; // Error: \`bar\` is required.
      <Component foo={1} bar={2} />; // OK
      return <Component foo={this.props.foo} bar={this.state.bar} />;
    }
  };
}

class Unwrapped extends React.Component<
  {
    foo: number,
    bar: number,
  },
  {
    buz: number,
  }
> {
  state = { buz: 3 };
  render() {
    return this.props.foo + this.props.bar + this.state.buz;
  }
}

function UnwrappedFun(props: { foo: number, bar: number }) {
  return props.foo + props.bar;
}

myHOC(class Empty extends React.Component<{ foo: string }, void> {}); // Error
myHOC(function Empty(props: { foo: string }) {}); // Error

const Wrapped: React$ComponentType<{ foo: number }> = myHOC(Unwrapped);
const WrappedFun = myHOC(UnwrappedFun);

<Wrapped nonsense="what" />; // Error: \`foo\` is required.
<Wrapped foo={1} />; // OK
<WrappedFun />; // Error: \`foo\` is required.
<WrappedFun foo={1} />; // OK

================================================================================
`;

exports[`hoc2.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

import * as React from 'react';

function connect<TProps>(
  Component: React.ComponentType<{|...TProps, prop: number|}>,
): React.ComponentType<TProps> {
  return (null: any);
}

class MyComponent extends React.Component<{|
  a: number,
  b: number,
  prop: number,
|}> { render() { return null }}

function MyFunctionComponent(props: {|
  a: number,
  b: number,
  prop: number,
|}) { return null }

const MyEnhancedComponent = connect(MyComponent);
const MyEnhancedFunctionComponent = connect(MyFunctionComponent);

<MyEnhancedComponent />; // Error: Needs \`a\` and \`b\`.
<MyEnhancedComponent a={1} b={2} />; // OK
<MyEnhancedComponent a="foo" b={2} />; // Error: string ~> number

<MyEnhancedFunctionComponent/>; // Error: Needs \`a\` and \`b\`.
<MyEnhancedFunctionComponent a={1} b={2} />; // OK
<MyEnhancedFunctionComponent a="foo" b={2} />; // Error: string ~> number

=====================================output=====================================
// @flow

import * as React from "react";

function connect<TProps>(
  Component: React.ComponentType<{| ...TProps, prop: number |}>
): React.ComponentType<TProps> {
  return (null: any);
}

class MyComponent extends React.Component<{|
  a: number,
  b: number,
  prop: number,
|}> {
  render() {
    return null;
  }
}

function MyFunctionComponent(props: {| a: number, b: number, prop: number |}) {
  return null;
}

const MyEnhancedComponent = connect(MyComponent);
const MyEnhancedFunctionComponent = connect(MyFunctionComponent);

<MyEnhancedComponent />; // Error: Needs \`a\` and \`b\`.
<MyEnhancedComponent a={1} b={2} />; // OK
<MyEnhancedComponent a="foo" b={2} />; // Error: string ~> number

<MyEnhancedFunctionComponent />; // Error: Needs \`a\` and \`b\`.
<MyEnhancedFunctionComponent a={1} b={2} />; // OK
<MyEnhancedFunctionComponent a="foo" b={2} />; // Error: string ~> number

================================================================================
`;

exports[`hoc3.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

import * as React from 'react';

function connect<TProps>(
  Component: React.ComponentType<{prop: number} & TProps>,
): React.ComponentType<TProps> {
  return (null: any);
}

class MyComponent extends React.Component<{
  a: number,
  b: number,
  prop: number,
}> { render() { return null } }

function MyFunctionComponent(props: {
  a: number,
  b: number,
  prop: number,
}) { return null }

const MyEnhancedComponent = connect(MyComponent);
const MyEnhancedFunctionComponent = connect(MyFunctionComponent);

<MyEnhancedComponent />; // Error: Needs \`a\` and \`b\`.
<MyEnhancedComponent a={1} b={2} />; // OK
<MyEnhancedComponent a="foo" b={2} />; // Error: string ~> number

<MyEnhancedFunctionComponent/>; // Error: Needs \`a\` and \`b\`.
<MyEnhancedFunctionComponent a={1} b={2} />; // OK
<MyEnhancedFunctionComponent a="foo" b={2} />; // Error: string ~> number

=====================================output=====================================
// @flow

import * as React from "react";

function connect<TProps>(
  Component: React.ComponentType<{ prop: number } & TProps>
): React.ComponentType<TProps> {
  return (null: any);
}

class MyComponent extends React.Component<{
  a: number,
  b: number,
  prop: number,
}> {
  render() {
    return null;
  }
}

function MyFunctionComponent(props: { a: number, b: number, prop: number }) {
  return null;
}

const MyEnhancedComponent = connect(MyComponent);
const MyEnhancedFunctionComponent = connect(MyFunctionComponent);

<MyEnhancedComponent />; // Error: Needs \`a\` and \`b\`.
<MyEnhancedComponent a={1} b={2} />; // OK
<MyEnhancedComponent a="foo" b={2} />; // Error: string ~> number

<MyEnhancedFunctionComponent />; // Error: Needs \`a\` and \`b\`.
<MyEnhancedFunctionComponent a={1} b={2} />; // OK
<MyEnhancedFunctionComponent a="foo" b={2} />; // Error: string ~> number

================================================================================
`;

exports[`hoc4.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

import * as React from 'react';

function connect<TProps>(
  Component: React.ComponentType<TProps>,
): React.ComponentType<$Diff<TProps, {prop: number}>> {
  return (null: any);
}

class MyComponent extends React.Component<{
  a: number,
  b: number,
  prop: number,
}> { render() { return null } }

function MyFunctionComponent(props: {
  a: number,
  b: number,
  prop: number,
}) { return null }

const MyEnhancedComponent = connect(MyComponent);
const MyEnhancedFunctionComponent = connect(MyFunctionComponent);

<MyEnhancedComponent />; // Error: Needs \`a\` and \`b\`.
<MyEnhancedComponent a={1} b={2} />; // OK
<MyEnhancedComponent a="foo" b={2} />; // Error: string ~> number

<MyEnhancedFunctionComponent/>; // Error: Needs \`a\` and \`b\`.
<MyEnhancedFunctionComponent a={1} b={2} />; // OK
<MyEnhancedFunctionComponent a="foo" b={2} />; // Error: string ~> number

=====================================output=====================================
// @flow

import * as React from "react";

function connect<TProps>(
  Component: React.ComponentType<TProps>
): React.ComponentType<$Diff<TProps, { prop: number }>> {
  return (null: any);
}

class MyComponent extends React.Component<{
  a: number,
  b: number,
  prop: number,
}> {
  render() {
    return null;
  }
}

function MyFunctionComponent(props: { a: number, b: number, prop: number }) {
  return null;
}

const MyEnhancedComponent = connect(MyComponent);
const MyEnhancedFunctionComponent = connect(MyFunctionComponent);

<MyEnhancedComponent />; // Error: Needs \`a\` and \`b\`.
<MyEnhancedComponent a={1} b={2} />; // OK
<MyEnhancedComponent a="foo" b={2} />; // Error: string ~> number

<MyEnhancedFunctionComponent />; // Error: Needs \`a\` and \`b\`.
<MyEnhancedFunctionComponent a={1} b={2} />; // OK
<MyEnhancedFunctionComponent a="foo" b={2} />; // Error: string ~> number

================================================================================
`;

exports[`hoc5.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/**
 * @format
 * @flow
 */

import * as React from 'react';

function hoc<Props, Component: React.ComponentType<Props>>(
  WrappedComponent: Component,
): React.ComponentType<React.ElementConfig<Component>> {
  return (props: Props) => <WrappedComponent {...props} />;
}

class MyComponent1 extends React.Component<{foo: string, bar: number}> {
  static defaultProps = {foo: 'qux'};
  render() {
    return null;
  }
}

function MyComponent2(props: {foo: string, bar: number}) {
  return null;
}
MyComponent2.defaultProps = {foo: 'qux'};

<MyComponent1 />; // Error
<MyComponent1 bar={42} />; // OK
<MyComponent1 bar="nope" />; // Error
<MyComponent1 bar={42} foo="zub" />; // OK
<MyComponent1 bar={42} foo={100} />; // Error
<MyComponent1 bar={42} foo={undefined} />; // OK

<MyComponent2 />; // Error
<MyComponent2 bar={42} />; // OK
<MyComponent2 bar="nope" />; // Error
<MyComponent2 bar={42} foo="zub" />; // OK
<MyComponent2 bar={42} foo={100} />; // Error
<MyComponent2 bar={42} foo={undefined} />; // OK

const MyEnhancedComponent1 = hoc(MyComponent1);
const MyEnhancedComponent2 = hoc(MyComponent2);

<MyEnhancedComponent1 />; // Error
<MyEnhancedComponent1 bar={42} />; // OK
<MyEnhancedComponent1 bar="nope" />; // Error
<MyEnhancedComponent1 bar={42} foo="zub" />; // OK
<MyEnhancedComponent1 bar={42} foo={100} />; // Error
<MyEnhancedComponent1 bar={42} foo={undefined} />; // OK

<MyEnhancedComponent2 />; // Error
<MyEnhancedComponent2 bar={42} />; // OK
<MyEnhancedComponent2 bar="nope" />; // Error
<MyEnhancedComponent2 bar={42} foo="zub" />; // OK
<MyEnhancedComponent2 bar={42} foo={100} />; // Error
<MyEnhancedComponent2 bar={42} foo={undefined} />; // OK

=====================================output=====================================
/**
 * @format
 * @flow
 */

import * as React from "react";

function hoc<Props, Component: React.ComponentType<Props>>(
  WrappedComponent: Component
): React.ComponentType<React.ElementConfig<Component>> {
  return (props: Props) => <WrappedComponent {...props} />;
}

class MyComponent1 extends React.Component<{ foo: string, bar: number }> {
  static defaultProps = { foo: "qux" };
  render() {
    return null;
  }
}

function MyComponent2(props: { foo: string, bar: number }) {
  return null;
}
MyComponent2.defaultProps = { foo: "qux" };

<MyComponent1 />; // Error
<MyComponent1 bar={42} />; // OK
<MyComponent1 bar="nope" />; // Error
<MyComponent1 bar={42} foo="zub" />; // OK
<MyComponent1 bar={42} foo={100} />; // Error
<MyComponent1 bar={42} foo={undefined} />; // OK

<MyComponent2 />; // Error
<MyComponent2 bar={42} />; // OK
<MyComponent2 bar="nope" />; // Error
<MyComponent2 bar={42} foo="zub" />; // OK
<MyComponent2 bar={42} foo={100} />; // Error
<MyComponent2 bar={42} foo={undefined} />; // OK

const MyEnhancedComponent1 = hoc(MyComponent1);
const MyEnhancedComponent2 = hoc(MyComponent2);

<MyEnhancedComponent1 />; // Error
<MyEnhancedComponent1 bar={42} />; // OK
<MyEnhancedComponent1 bar="nope" />; // Error
<MyEnhancedComponent1 bar={42} foo="zub" />; // OK
<MyEnhancedComponent1 bar={42} foo={100} />; // Error
<MyEnhancedComponent1 bar={42} foo={undefined} />; // OK

<MyEnhancedComponent2 />; // Error
<MyEnhancedComponent2 bar={42} />; // OK
<MyEnhancedComponent2 bar="nope" />; // Error
<MyEnhancedComponent2 bar={42} foo="zub" />; // OK
<MyEnhancedComponent2 bar={42} foo={100} />; // Error
<MyEnhancedComponent2 bar={42} foo={undefined} />; // OK

================================================================================
`;

exports[`import_react.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/* @flow */

import react from "react";
import {Component} from "react";

var a: Component<*> = new react.Component();
var b: number = new react.Component(); // Error: ReactComponent ~> number

=====================================output=====================================
/* @flow */

import react from "react";
import { Component } from "react";

var a: Component<*> = new react.Component();
var b: number = new react.Component(); // Error: ReactComponent ~> number

================================================================================
`;

exports[`intersection_component_error.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/**
 * @format
 * @flow
 */

import * as React from 'react';

declare var MyComponent: React.ComponentType<{foo: number}> & {
  someStatic: boolean,
};

<MyComponent />;

=====================================output=====================================
/**
 * @format
 * @flow
 */

import * as React from "react";

declare var MyComponent: React.ComponentType<{ foo: number }> & {
  someStatic: boolean,
};

<MyComponent />;

================================================================================
`;

exports[`jsx_any_spread.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

const React = require('react');

const any: any = null;

class Foo extends React.Component<{a: number, b: number, c: number}> {}

<Foo {...(any: Object)} />;

=====================================output=====================================
// @flow

const React = require("react");

const any: any = null;

class Foo extends React.Component<{ a: number, b: number, c: number }> {}

<Foo {...(any: Object)} />;

================================================================================
`;

exports[`jsx_spread.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/* @flow */

var React = require('react');
var Foo = React.createClass({
  propTypes: {
    bar: React.PropTypes.string.isRequired,
  },
});

var props = {bar: 42};
var blah = <Foo {...props} />; // error bar, number given string expected

=====================================output=====================================
/* @flow */

var React = require("react");
var Foo = React.createClass({
  propTypes: {
    bar: React.PropTypes.string.isRequired,
  },
});

var props = { bar: 42 };
var blah = <Foo {...props} />; // error bar, number given string expected

================================================================================
`;

exports[`key.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

import React from 'react';

class Foo extends React.Component<{}, void> {}

<Foo />; // OK
<Foo key="42" />; // OK
<Foo key={42} />; // OK
<Foo key={null} />; // OK
<Foo key={undefined} />; // OK
<Foo key={true} />; // Error

class FooExact extends React.Component<{||}, void> {}

<FooExact />; // OK
<FooExact key="42" />; // OK
<FooExact key={42} />; // OK
<FooExact key={null} />; // OK
<FooExact key={undefined} />; // OK
<FooExact key={true} />; // Error

=====================================output=====================================
// @flow

import React from "react";

class Foo extends React.Component<{}, void> {}

<Foo />; // OK
<Foo key="42" />; // OK
<Foo key={42} />; // OK
<Foo key={null} />; // OK
<Foo key={undefined} />; // OK
<Foo key={true} />; // Error

class FooExact extends React.Component<{||}, void> {}

<FooExact />; // OK
<FooExact key="42" />; // OK
<FooExact key={42} />; // OK
<FooExact key={null} />; // OK
<FooExact key={undefined} />; // OK
<FooExact key={true} />; // Error

================================================================================
`;

exports[`opaue_default.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

/* This is a regression test. When the config passed to createElement and the
 * component's defaultProps both define a given property, we do a CondT test to
 * ensure that void-typed config values are replaced with the default value.
 * This CondT check used to unwrap opaque types with a declared supertype, which
 * would cause an error. Instead, we need to preserve the unwrapped opaque type.
 */

const React = require("react");

declare opaque type T: string;
declare var x: T;

type Props = { foo: T }

class C extends React.Component<Props, void> {
  static defaultProps = { foo: x };
}

(<C foo={x} />); // OK

=====================================output=====================================
// @flow

/* This is a regression test. When the config passed to createElement and the
 * component's defaultProps both define a given property, we do a CondT test to
 * ensure that void-typed config values are replaced with the default value.
 * This CondT check used to unwrap opaque types with a declared supertype, which
 * would cause an error. Instead, we need to preserve the unwrapped opaque type.
 */

const React = require("react");

declare opaque type T: string;
declare var x: T;

type Props = { foo: T };

class C extends React.Component<Props, void> {
  static defaultProps = { foo: x };
}

<C foo={x} />; // OK

================================================================================
`;

exports[`portals.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

import * as React from 'react';
import * as ReactDOM from 'react-dom';

declare class MyPortalComponent extends React.Component<{}> {}

class MyComponent extends React.Component<{}> {
  render() {
    return ReactDOM.createPortal(
      <MyPortalComponent />,
      test$getElementById('portal'),
    );
  }
}

=====================================output=====================================
// @flow

import * as React from "react";
import * as ReactDOM from "react-dom";

declare class MyPortalComponent extends React.Component<{}> {}

class MyComponent extends React.Component<{}> {
  render() {
    return ReactDOM.createPortal(
      <MyPortalComponent />,
      test$getElementById("portal")
    );
  }
}

================================================================================
`;

exports[`proptype_any.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
const React = require("react");

var AnyExample = React.createClass({
  propTypes: {
    foo: (0: any), // OK
  },
});

(<AnyExample />); // OK
(<AnyExample foo={(0: mixed)} />); // OK

var AnyFunExample = React.createClass({
  propTypes: {
    foo: (() => {}: Function), // OK
  },
});

(<AnyFunExample />); // OK
(<AnyFunExample foo={(0: mixed)} />); // OK

=====================================output=====================================
const React = require("react");

var AnyExample = React.createClass({
  propTypes: {
    foo: (0: any), // OK
  },
});

<AnyExample />; // OK
<AnyExample foo={(0: mixed)} />; // OK

var AnyFunExample = React.createClass({
  propTypes: {
    foo: (() => {}: Function), // OK
  },
});

<AnyFunExample />; // OK
<AnyFunExample foo={(0: mixed)} />; // OK

================================================================================
`;

exports[`proptype_arrayOf.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/* @flow */

var React = require('react');
var Example = React.createClass({
  propTypes: {
    arr: React.PropTypes.arrayOf(React.PropTypes.number).isRequired,
  },
});

var ok_empty = <Example arr={[]} />
var ok_numbers = <Example arr={[1, 2]} />

var fail_missing = <Example />
var fail_not_array = <Example arr={2} />
var fail_mistyped_elems = <Example arr={[1, "foo"]} />

/* Since the \`number\` proptype argument is not required, React will actually
   allow \`null\` and \`undefined\` elements in the \`arr\` prop, but Flow has
   currently ignores the innter prop type's required flag. */
var todo_required = <Example arr={[null]} />

var OptionalExample = React.createClass({
  propTypes: {
    arr: React.PropTypes.arrayOf(React.PropTypes.number),
  }
});

(<OptionalExample />); // OK
(<OptionalExample arr={[0]} />); // OK
(<OptionalExample arr={[""]} />); // error: string ~> number

var AnyExample = React.createClass({
  propTypes: {
    arr: React.PropTypes.arrayOf((0:any)), // OK
  },
});

(<AnyExample arr={0} />); // error: still needs to be an array
(<AnyExample arr={[0]} />); // OK

var InvalidExample = React.createClass({
  propTypes: {
    arr: React.PropTypes.arrayOf(0), // error: number not a prop type
  },
});

=====================================output=====================================
/* @flow */

var React = require("react");
var Example = React.createClass({
  propTypes: {
    arr: React.PropTypes.arrayOf(React.PropTypes.number).isRequired,
  },
});

var ok_empty = <Example arr={[]} />;
var ok_numbers = <Example arr={[1, 2]} />;

var fail_missing = <Example />;
var fail_not_array = <Example arr={2} />;
var fail_mistyped_elems = <Example arr={[1, "foo"]} />;

/* Since the \`number\` proptype argument is not required, React will actually
   allow \`null\` and \`undefined\` elements in the \`arr\` prop, but Flow has
   currently ignores the innter prop type's required flag. */
var todo_required = <Example arr={[null]} />;

var OptionalExample = React.createClass({
  propTypes: {
    arr: React.PropTypes.arrayOf(React.PropTypes.number),
  },
});

<OptionalExample />; // OK
<OptionalExample arr={[0]} />; // OK
<OptionalExample arr={[""]} />; // error: string ~> number

var AnyExample = React.createClass({
  propTypes: {
    arr: React.PropTypes.arrayOf((0: any)), // OK
  },
});

<AnyExample arr={0} />; // error: still needs to be an array
<AnyExample arr={[0]} />; // OK

var InvalidExample = React.createClass({
  propTypes: {
    arr: React.PropTypes.arrayOf(0), // error: number not a prop type
  },
});

================================================================================
`;

exports[`proptype_custom_validator.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
const React = require("react");

// Custom validator must match \`ReactPropsCheckType\`
var Example = React.createClass({
  propTypes: {
    foo(props, propName, componentName, href) {
      (props: empty); // ok: props is \`any\`
      (propName: empty); // error: propName is a string
      (componentName: empty); // error: componentName is a string
      (href: empty); // error: href is an optional string
      return (0: mixed); // error: should return ?Error
    },
  }
});

// Inferred prop type is optional \`any\`
(<Example />);
(<Example foo={(0: mixed)} />);

=====================================output=====================================
const React = require("react");

// Custom validator must match \`ReactPropsCheckType\`
var Example = React.createClass({
  propTypes: {
    foo(props, propName, componentName, href) {
      (props: empty); // ok: props is \`any\`
      (propName: empty); // error: propName is a string
      (componentName: empty); // error: componentName is a string
      (href: empty); // error: href is an optional string
      return (0: mixed); // error: should return ?Error
    },
  },
});

// Inferred prop type is optional \`any\`
<Example />;
<Example foo={(0: mixed)} />;

================================================================================
`;

exports[`proptype_func.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/* @flow */

var React = require('react');
var Example = React.createClass({
  propTypes: {
    func: React.PropTypes.func.isRequired
  },
});

var ok_void = <Example func={() => {}} />;
var ok_args = <Example func={(x) => {}} />;
var ok_retval = <Example func={() => 1} />

var fail_mistyped = <Example func={2} />

=====================================output=====================================
/* @flow */

var React = require("react");
var Example = React.createClass({
  propTypes: {
    func: React.PropTypes.func.isRequired,
  },
});

var ok_void = <Example func={() => {}} />;
var ok_args = <Example func={(x) => {}} />;
var ok_retval = <Example func={() => 1} />;

var fail_mistyped = <Example func={2} />;

================================================================================
`;

exports[`proptype_incompatible.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
const React = require("react");

var Example = React.createClass({
  propTypes: {
    foo: 0, // error: \`0\` is not a prop type
  },
});

(<Example />); // OK: don't cascade errors
(<Example foo={(0:mixed)} />); // OK: don't cascade errors

=====================================output=====================================
const React = require("react");

var Example = React.createClass({
  propTypes: {
    foo: 0, // error: \`0\` is not a prop type
  },
});

<Example />; // OK: don't cascade errors
<Example foo={(0: mixed)} />; // OK: don't cascade errors

================================================================================
`;

exports[`proptype_instanceOf.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/* @flow */

class A {}
class B extends A {}
class C extends B {}

var React = require('react');
var Example = React.createClass({
  propTypes: {
    x: React.PropTypes.instanceOf(B),
  }
});

(<Example x={new A} />); // error: A ~> B
(<Example x={new B} />); // OK
(<Example x={new C} />); // OK (C ~> B)
(<Example x="wrong" />); // error: string ~> B

class Poly<T> {x:T}
var PolyExample = React.createClass({
  propTypes: {
    x: React.PropTypes.instanceOf(Poly).isRequired,
  },
  m() {
    (this.props.x.x: empty); // OK, T instantiated to \`any\`
  }
});

// Different instantiations don't interact
(<PolyExample x={(new Poly(): Poly<string>)} />); // OK
(<PolyExample x={(new Poly(): Poly<number>)} />); // OK

class PolyDefault<T=string> {x:T}
var PolyDefaultExample = React.createClass({
  propTypes: {
    x: React.PropTypes.instanceOf(PolyDefault).isRequired,
  },
  m() {
    (this.props.x.x: empty); // OK, T instantiated to \`any\`
  }
});

=====================================output=====================================
/* @flow */

class A {}
class B extends A {}
class C extends B {}

var React = require("react");
var Example = React.createClass({
  propTypes: {
    x: React.PropTypes.instanceOf(B),
  },
});

<Example x={new A()} />; // error: A ~> B
<Example x={new B()} />; // OK
<Example x={new C()} />; // OK (C ~> B)
<Example x="wrong" />; // error: string ~> B

class Poly<T> {
  x: T;
}
var PolyExample = React.createClass({
  propTypes: {
    x: React.PropTypes.instanceOf(Poly).isRequired,
  },
  m() {
    (this.props.x.x: empty); // OK, T instantiated to \`any\`
  },
});

// Different instantiations don't interact
<PolyExample x={(new Poly(): Poly<string>)} />; // OK
<PolyExample x={(new Poly(): Poly<number>)} />; // OK

class PolyDefault<T = string> {
  x: T;
}
var PolyDefaultExample = React.createClass({
  propTypes: {
    x: React.PropTypes.instanceOf(PolyDefault).isRequired,
  },
  m() {
    (this.props.x.x: empty); // OK, T instantiated to \`any\`
  },
});

================================================================================
`;

exports[`proptype_missing.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/* @flow */

/* If you create a react component with createClass() but don't specify the
 * propTypes, what should the type of props be?
 *
 * It used to be an empty object, but we didn't enforce that correctly, so
 * people could do whatever they wanted with this.props.
 *
 * As of 0.21.0 it started to be an error when people used this.props in a
 * strict equality situation. It was weird that this was only sometimes
 * enforced, so glevi changed this.props to be Object by default.
 *
 * We may change this back to the empty object at some point and fix the
 * situations where it didn't used to error
 */
var React = require('react');
var Foo = React.createClass({
  getID(): string {
    // So this would have been an error in 0.21.0 if we didn't make this.props
    // Object
    switch (this.props.name) {
      case 'a': return 'Bob';
      default: return 'Alice';
    }
  },

  render() {
    // But this never errored
    return <div id={this.props.name} />;
  }
});

=====================================output=====================================
/* @flow */

/* If you create a react component with createClass() but don't specify the
 * propTypes, what should the type of props be?
 *
 * It used to be an empty object, but we didn't enforce that correctly, so
 * people could do whatever they wanted with this.props.
 *
 * As of 0.21.0 it started to be an error when people used this.props in a
 * strict equality situation. It was weird that this was only sometimes
 * enforced, so glevi changed this.props to be Object by default.
 *
 * We may change this back to the empty object at some point and fix the
 * situations where it didn't used to error
 */
var React = require("react");
var Foo = React.createClass({
  getID(): string {
    // So this would have been an error in 0.21.0 if we didn't make this.props
    // Object
    switch (this.props.name) {
      case "a":
        return "Bob";
      default:
        return "Alice";
    }
  },

  render() {
    // But this never errored
    return <div id={this.props.name} />;
  },
});

================================================================================
`;

exports[`proptype_object.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/* @flow */

var React = require('react');
var Example = React.createClass({
  propTypes: {
    object: React.PropTypes.object.isRequired
  },
});

var ok_empty = <Example object={{}} />;
var ok_props = <Example object={{foo: "bar"}} />;

var fail_mistyped = <Example object={2} />

=====================================output=====================================
/* @flow */

var React = require("react");
var Example = React.createClass({
  propTypes: {
    object: React.PropTypes.object.isRequired,
  },
});

var ok_empty = <Example object={{}} />;
var ok_props = <Example object={{ foo: "bar" }} />;

var fail_mistyped = <Example object={2} />;

================================================================================
`;

exports[`proptype_objectOf.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/* @flow */

var React = require('react');
var Example = React.createClass({
  propTypes: {
    obj: React.PropTypes.objectOf(React.PropTypes.number).isRequired
  },
});

var ok_empty = <Example obj={{}} />
var ok_numbers = <Example obj={{foo: 1, bar: 2}} />

var fail_missing = <Example />
var fail_not_object = <Example obj={2} />
var fail_mistyped_props = <Example obj={{foo: "foo"}} />

/* Since the \`number\` proptype argument is not required, React will actually
   allow \`null\` and \`undefined\` elements in the \`obj\` prop, but Flow has
   currently ignores the innter prop type's required flag. */
var todo_required = <Example obj={{p:null}} />

var OptionalExample = React.createClass({
  propTypes: {
    obj: React.PropTypes.objectOf(React.PropTypes.number),
  }
});

(<OptionalExample />); // OK
(<OptionalExample obj={{p:0}} />); // OK
(<OptionalExample obj={{p:""}} />); // error: string ~> number

var AnyExample = React.createClass({
  propTypes: {
    obj: React.PropTypes.objectOf((0:any)), // OK
  },
});

(<AnyExample obj={0} />); // error: still needs to be an object
(<AnyExample obj={{p:0}} />); // OK

var InvalidExample = React.createClass({
  propTypes: {
    obj: React.PropTypes.objectOf(0), // error: number not a prop type
  },
});

=====================================output=====================================
/* @flow */

var React = require("react");
var Example = React.createClass({
  propTypes: {
    obj: React.PropTypes.objectOf(React.PropTypes.number).isRequired,
  },
});

var ok_empty = <Example obj={{}} />;
var ok_numbers = <Example obj={{ foo: 1, bar: 2 }} />;

var fail_missing = <Example />;
var fail_not_object = <Example obj={2} />;
var fail_mistyped_props = <Example obj={{ foo: "foo" }} />;

/* Since the \`number\` proptype argument is not required, React will actually
   allow \`null\` and \`undefined\` elements in the \`obj\` prop, but Flow has
   currently ignores the innter prop type's required flag. */
var todo_required = <Example obj={{ p: null }} />;

var OptionalExample = React.createClass({
  propTypes: {
    obj: React.PropTypes.objectOf(React.PropTypes.number),
  },
});

<OptionalExample />; // OK
<OptionalExample obj={{ p: 0 }} />; // OK
<OptionalExample obj={{ p: "" }} />; // error: string ~> number

var AnyExample = React.createClass({
  propTypes: {
    obj: React.PropTypes.objectOf((0: any)), // OK
  },
});

<AnyExample obj={0} />; // error: still needs to be an object
<AnyExample obj={{ p: 0 }} />; // OK

var InvalidExample = React.createClass({
  propTypes: {
    obj: React.PropTypes.objectOf(0), // error: number not a prop type
  },
});

================================================================================
`;

exports[`proptype_oneOf.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/* @flow */

var React = require('react');
var Example = React.createClass({
  propTypes: {
    str: React.PropTypes.oneOf(["foo", "bar"]),
    num: React.PropTypes.oneOf([0, 1, 2]),
    bool: React.PropTypes.oneOf([true]),
    mixed: React.PropTypes.oneOf(["foo", 0, true]),
  },
});

(<Example str="foo" />); // OK
(<Example str="baz" />); // error: 'baz' not in enum

(<Example num={0} />); // OK
(<Example num={3} />); // error: 3 not in enum

(<Example bool={true} />); // OK
(<Example bool={false} />); // error: false ~> true

(<Example mixed={"foo"} />); // OK
(<Example mixed={0} />); // OK
(<Example mixed={"baz"} />); // error: 'baz' not in enum

var RequiredExample = React.createClass({
  propTypes: {
    p: React.PropTypes.oneOf([]).isRequired,
  },
});

(<RequiredExample />); // error: \`p\` not found

var EmptyExample = React.createClass({
  propTypes: {
    nil: React.PropTypes.oneOf([]), // i.e., \`empty\`
  },
});

(<EmptyExample nil={0} />); // number ~> empty

var AnyArrayExample = React.createClass({
  propTypes: {
    any: React.PropTypes.oneOf((0:any)),
  },
});

(<AnyArrayExample any={0} />); // OK

var AnyElemExample = React.createClass({
  propTypes: {
    any: React.PropTypes.oneOf(["foo", (0:any)]),
  },
});

(<AnyElemExample any={0} />); // OK

var DynamicArrayExample = React.createClass({
  propTypes: {
    dyn: React.PropTypes.oneOf(([]: Array<string>)),
  },
});

(<DynamicArrayExample dyn={0} />); // OK

var DynamicElemExample = React.createClass({
  propTypes: {
    dyn: React.PropTypes.oneOf(["foo", ("": string)]),
  },
});

(<DynamicElemExample dyn={0} />); // OK

var InvalidArrayExample = React.createClass({
  propTypes: {
    p: React.PropTypes.oneOf(0), // error: expected array, got 0
  },
});

(<InvalidArrayExample p={0} />); // OK, don't cascade errors

var NonLiteralElemExample = React.createClass({
  propTypes: {
    p: React.PropTypes.oneOf([{}]), // OK: allow non-literals
  },
});
(<NonLiteralElemExample p={0} />); // OK, result is unknown/any

=====================================output=====================================
/* @flow */

var React = require("react");
var Example = React.createClass({
  propTypes: {
    str: React.PropTypes.oneOf(["foo", "bar"]),
    num: React.PropTypes.oneOf([0, 1, 2]),
    bool: React.PropTypes.oneOf([true]),
    mixed: React.PropTypes.oneOf(["foo", 0, true]),
  },
});

<Example str="foo" />; // OK
<Example str="baz" />; // error: 'baz' not in enum

<Example num={0} />; // OK
<Example num={3} />; // error: 3 not in enum

<Example bool={true} />; // OK
<Example bool={false} />; // error: false ~> true

<Example mixed={"foo"} />; // OK
<Example mixed={0} />; // OK
<Example mixed={"baz"} />; // error: 'baz' not in enum

var RequiredExample = React.createClass({
  propTypes: {
    p: React.PropTypes.oneOf([]).isRequired,
  },
});

<RequiredExample />; // error: \`p\` not found

var EmptyExample = React.createClass({
  propTypes: {
    nil: React.PropTypes.oneOf([]), // i.e., \`empty\`
  },
});

<EmptyExample nil={0} />; // number ~> empty

var AnyArrayExample = React.createClass({
  propTypes: {
    any: React.PropTypes.oneOf((0: any)),
  },
});

<AnyArrayExample any={0} />; // OK

var AnyElemExample = React.createClass({
  propTypes: {
    any: React.PropTypes.oneOf(["foo", (0: any)]),
  },
});

<AnyElemExample any={0} />; // OK

var DynamicArrayExample = React.createClass({
  propTypes: {
    dyn: React.PropTypes.oneOf(([]: Array<string>)),
  },
});

<DynamicArrayExample dyn={0} />; // OK

var DynamicElemExample = React.createClass({
  propTypes: {
    dyn: React.PropTypes.oneOf(["foo", ("": string)]),
  },
});

<DynamicElemExample dyn={0} />; // OK

var InvalidArrayExample = React.createClass({
  propTypes: {
    p: React.PropTypes.oneOf(0), // error: expected array, got 0
  },
});

<InvalidArrayExample p={0} />; // OK, don't cascade errors

var NonLiteralElemExample = React.createClass({
  propTypes: {
    p: React.PropTypes.oneOf([{}]), // OK: allow non-literals
  },
});
<NonLiteralElemExample p={0} />; // OK, result is unknown/any

================================================================================
`;

exports[`proptype_oneOfType.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/* @flow */

var React = require('react');
var Example = React.createClass({
  propTypes: {
    prop: React.PropTypes.oneOfType([
      React.PropTypes.string,
      React.PropTypes.number
    ]).isRequired
  },
  render() {
    if (typeof this.props.prop === "string") {
      return <div>{this.props.prop}</div>
    } else {
      return <div>{this.props.prop.toFixed(2)}</div>
    }
  }
});

var ok_number = <Example prop={42} />;
var ok_string = <Example prop="bar" />;

var fail_missing = <Example />;
var fail_bool = <Example prop={true} />;

/* Since the proptype arguments are not required, React will actually allow
   \`null\` and \`undefined\` elements in the \`prop\` prop, but Flow has currently
   ignores the innter prop types' required flags. */
var todo_required = <Example prop={null} />;

var OptionalExample = React.createClass({
  propTypes: {
    p: React.PropTypes.oneOfType([
      React.PropTypes.string,
    ]),
  },
});

(<OptionalExample />); // OK
(<OptionalExample p="" />); // OK
(<OptionalExample p={0} />); // error: number ~> string

var EmptyExample = React.createClass({
  propTypes: {
    nil: React.PropTypes.oneOfType([]), // i.e., \`empty\`
  },
});

(<EmptyExample nil={0} />); // number ~> empty

var AnyArrayExample = React.createClass({
  propTypes: {
    any: React.PropTypes.oneOfType((0:any)),
  },
});

(<AnyArrayExample any={0} />); // OK

var AnyElemExample = React.createClass({
  propTypes: {
    any: React.PropTypes.oneOfType([
      React.PropTypes.string,
      (0:any),
    ]),
  },
});

(<AnyElemExample any={0} />); // OK

var DynamicArrayExample = React.createClass({
  propTypes: {
    dyn: React.PropTypes.oneOfType(([]: Array<Function>)),
  },
});

(<DynamicArrayExample dyn={0} />); // OK

var DynamicElemExample = React.createClass({
  propTypes: {
    dyn: React.PropTypes.oneOfType([
      React.PropTypes.string,
      (() => {}: Function),
    ]),
  },
});

(<DynamicElemExample dyn={0} />); // OK

var InvalidArrayExample = React.createClass({
  propTypes: {
    p: React.PropTypes.oneOfType(0), // error: expected array, got 0
  },
});

(<InvalidArrayExample p={0} />); // OK, don't cascade errors

var InvalidElemExample = React.createClass({
  propTypes: {
    p: React.PropTypes.oneOfType([{}]), // error: expected prop type, got {}
  },
});

(<InvalidElemExample p={0} />); // OK, don't cascade errors

=====================================output=====================================
/* @flow */

var React = require("react");
var Example = React.createClass({
  propTypes: {
    prop: React.PropTypes.oneOfType([
      React.PropTypes.string,
      React.PropTypes.number,
    ]).isRequired,
  },
  render() {
    if (typeof this.props.prop === "string") {
      return <div>{this.props.prop}</div>;
    } else {
      return <div>{this.props.prop.toFixed(2)}</div>;
    }
  },
});

var ok_number = <Example prop={42} />;
var ok_string = <Example prop="bar" />;

var fail_missing = <Example />;
var fail_bool = <Example prop={true} />;

/* Since the proptype arguments are not required, React will actually allow
   \`null\` and \`undefined\` elements in the \`prop\` prop, but Flow has currently
   ignores the innter prop types' required flags. */
var todo_required = <Example prop={null} />;

var OptionalExample = React.createClass({
  propTypes: {
    p: React.PropTypes.oneOfType([React.PropTypes.string]),
  },
});

<OptionalExample />; // OK
<OptionalExample p="" />; // OK
<OptionalExample p={0} />; // error: number ~> string

var EmptyExample = React.createClass({
  propTypes: {
    nil: React.PropTypes.oneOfType([]), // i.e., \`empty\`
  },
});

<EmptyExample nil={0} />; // number ~> empty

var AnyArrayExample = React.createClass({
  propTypes: {
    any: React.PropTypes.oneOfType((0: any)),
  },
});

<AnyArrayExample any={0} />; // OK

var AnyElemExample = React.createClass({
  propTypes: {
    any: React.PropTypes.oneOfType([React.PropTypes.string, (0: any)]),
  },
});

<AnyElemExample any={0} />; // OK

var DynamicArrayExample = React.createClass({
  propTypes: {
    dyn: React.PropTypes.oneOfType(([]: Array<Function>)),
  },
});

<DynamicArrayExample dyn={0} />; // OK

var DynamicElemExample = React.createClass({
  propTypes: {
    dyn: React.PropTypes.oneOfType([
      React.PropTypes.string,
      (() => {}: Function),
    ]),
  },
});

<DynamicElemExample dyn={0} />; // OK

var InvalidArrayExample = React.createClass({
  propTypes: {
    p: React.PropTypes.oneOfType(0), // error: expected array, got 0
  },
});

<InvalidArrayExample p={0} />; // OK, don't cascade errors

var InvalidElemExample = React.createClass({
  propTypes: {
    p: React.PropTypes.oneOfType([{}]), // error: expected prop type, got {}
  },
});

<InvalidElemExample p={0} />; // OK, don't cascade errors

================================================================================
`;

exports[`proptype_shape.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/* Shape should be a sealed, inexact object just like a type annotation. The
 * below component's \`foo\` property should be equivalent to \`{ bar: string }\`,
 * which would forbid reads/writes on an unknown \`baz\` property.
 *
 * If you see a single "number incompatible with string" error instead of two
 * separate "property \`baz\` not found" errors, this is broken and we are
 * treating the shape like an unsealed object and performing shadow read/writes.
 */

import React from "react";

React.createClass({
  propTypes: {
    foo: React.PropTypes.shape({
      bar: React.PropTypes.string.isRequired,
    }).isRequired,
  },

  f() {
    (this.props.foo.baz: string);
  },

  g() {
    this.props.foo.baz = 0;
  }
});

React.createClass({
  propTypes: {
    foo: React.PropTypes.shape(({}: {[string]: any})).isRequired,
  },
  f() {
    (this.props.foo.bar: empty); // OK
  },
});

=====================================output=====================================
/* Shape should be a sealed, inexact object just like a type annotation. The
 * below component's \`foo\` property should be equivalent to \`{ bar: string }\`,
 * which would forbid reads/writes on an unknown \`baz\` property.
 *
 * If you see a single "number incompatible with string" error instead of two
 * separate "property \`baz\` not found" errors, this is broken and we are
 * treating the shape like an unsealed object and performing shadow read/writes.
 */

import React from "react";

React.createClass({
  propTypes: {
    foo: React.PropTypes.shape({
      bar: React.PropTypes.string.isRequired,
    }).isRequired,
  },

  f() {
    (this.props.foo.baz: string);
  },

  g() {
    this.props.foo.baz = 0;
  },
});

React.createClass({
  propTypes: {
    foo: React.PropTypes.shape(({}: { [string]: any })).isRequired,
  },
  f() {
    (this.props.foo.bar: empty); // OK
  },
});

================================================================================
`;

exports[`proptypes_builtins.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
import React from "react";

type NoFun = mixed => empty;

// error: mixed ~> ReactPropsCheckType
// error: ReactPropsChainableTypeChecker ~> empty
(React.PropTypes.arrayOf : NoFun);

// OK: mixed ~> any
// error: ReactPropsChainableTypeChecker ~> empty
(React.PropTypes.instanceOf : NoFun);

// error: mixed ~> ReactPropsCheckType
// error: ReactPropsChainableTypeChecker ~> empty
(React.PropTypes.objectOf : NoFun);

// error: mixed ~> Array<any>
// error: ReactPropsChainableTypeChecker ~> empty
(React.PropTypes.oneOf : NoFun);

// error: mixed ~> Array<ReactPropsCheckType>
// error: ReactPropsChainableTypeChecker ~> empty
(React.PropTypes.oneOfType : NoFun);

// error: mixed ~> object type
// error: ReactPropsChainableTypeChecker ~> empty
(React.PropTypes.shape : NoFun);

=====================================output=====================================
import React from "react";

type NoFun = (mixed) => empty;

// error: mixed ~> ReactPropsCheckType
// error: ReactPropsChainableTypeChecker ~> empty
(React.PropTypes.arrayOf: NoFun);

// OK: mixed ~> any
// error: ReactPropsChainableTypeChecker ~> empty
(React.PropTypes.instanceOf: NoFun);

// error: mixed ~> ReactPropsCheckType
// error: ReactPropsChainableTypeChecker ~> empty
(React.PropTypes.objectOf: NoFun);

// error: mixed ~> Array<any>
// error: ReactPropsChainableTypeChecker ~> empty
(React.PropTypes.oneOf: NoFun);

// error: mixed ~> Array<ReactPropsCheckType>
// error: ReactPropsChainableTypeChecker ~> empty
(React.PropTypes.oneOfType: NoFun);

// error: mixed ~> object type
// error: ReactPropsChainableTypeChecker ~> empty
(React.PropTypes.shape: NoFun);

================================================================================
`;

exports[`proptypes_sealed.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/* propTypes should be a sealed, inexact object just like a type annotation. The
 * below component's propTypes should be equivalent to \`{ bar: string }\`, which
 * would forbid reads/writes on an unknown \`baz\` property.
 *
 * If you see a single "number incompatible with string" error instead of two
 * separate "property \`baz\` not found" errors, this is broken and we are
 * treating propTypes like an unsealed object and performing shadow read/writes.
 */

import React from "react";

React.createClass({
  propTypes: {
    foo: React.PropTypes.string.isRequired,
  },

  f() {
    (this.props.baz: string);
  },

  g() {
    this.props.baz = 0;
  }
});

=====================================output=====================================
/* propTypes should be a sealed, inexact object just like a type annotation. The
 * below component's propTypes should be equivalent to \`{ bar: string }\`, which
 * would forbid reads/writes on an unknown \`baz\` property.
 *
 * If you see a single "number incompatible with string" error instead of two
 * separate "property \`baz\` not found" errors, this is broken and we are
 * treating propTypes like an unsealed object and performing shadow read/writes.
 */

import React from "react";

React.createClass({
  propTypes: {
    foo: React.PropTypes.string.isRequired,
  },

  f() {
    (this.props.baz: string);
  },

  g() {
    this.props.baz = 0;
  },
});

================================================================================
`;

exports[`ref.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

import React from 'react';

class Foo extends React.Component<{}, void> {}
class Bar extends React.Component<{}, void> {}

<Foo />; // OK
<Foo ref="foo" />; // OK
<Foo ref={null} />; // OK
<Foo ref={undefined} />; // OK
<Foo ref={(foo: number) => {}} />; // Error: \`Foo\` is not a \`number\`.
<Foo ref={foo => (foo: Foo)} />; // Error: \`Foo\` may be null.
<Foo ref={foo => (foo: Foo | null)} />; // OK
<Foo ref={foo => (foo: Bar | null)} />; // Error: \`Foo\` is not \`Bar\`.

class FooExact extends React.Component<{||}, void> {}

<FooExact />; // OK
<FooExact ref="foo" />; // OK
<FooExact ref={null} />; // OK
<FooExact ref={undefined} />; // OK
<FooExact ref={(foo: number) => {}} />; // Error: \`FooExact\` is not a \`number\`.
<FooExact ref={foo => (foo: FooExact)} />; // Error: \`FooExact\` may be null.
<FooExact ref={foo => (foo: FooExact | null)} />; // OK
<FooExact ref={foo => (foo: Bar | null)} />; // Error: \`FooExact\` is not \`Bar\`.

class NumRefs extends React.Component<{}> {
  getChild(i: number) {
    return this.refs[i];
  }
  render() {
    var children = [];
    for (var i = 0; i < 10; i++) {
      children.push(<div ref={i} />);
    }
    return children;
  }
}

=====================================output=====================================
// @flow

import React from "react";

class Foo extends React.Component<{}, void> {}
class Bar extends React.Component<{}, void> {}

<Foo />; // OK
<Foo ref="foo" />; // OK
<Foo ref={null} />; // OK
<Foo ref={undefined} />; // OK
<Foo ref={(foo: number) => {}} />; // Error: \`Foo\` is not a \`number\`.
<Foo ref={(foo) => (foo: Foo)} />; // Error: \`Foo\` may be null.
<Foo ref={(foo) => (foo: Foo | null)} />; // OK
<Foo ref={(foo) => (foo: Bar | null)} />; // Error: \`Foo\` is not \`Bar\`.

class FooExact extends React.Component<{||}, void> {}

<FooExact />; // OK
<FooExact ref="foo" />; // OK
<FooExact ref={null} />; // OK
<FooExact ref={undefined} />; // OK
<FooExact ref={(foo: number) => {}} />; // Error: \`FooExact\` is not a \`number\`.
<FooExact ref={(foo) => (foo: FooExact)} />; // Error: \`FooExact\` may be null.
<FooExact ref={(foo) => (foo: FooExact | null)} />; // OK
<FooExact ref={(foo) => (foo: Bar | null)} />; // Error: \`FooExact\` is not \`Bar\`.

class NumRefs extends React.Component<{}> {
  getChild(i: number) {
    return this.refs[i];
  }
  render() {
    var children = [];
    for (var i = 0; i < 10; i++) {
      children.push(<div ref={i} />);
    }
    return children;
  }
}

================================================================================
`;

exports[`render.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

import React from 'react';

/**
 * Basic render: Class component tests
 */
class A extends React.Component<{}, void> {
  render = () => {};
}
class B extends React.Component<{}, void> {
  render = () => null;
}

<A />;
// Error: \`render\` should return a \`React$Node\` which can't be undefined

<B />;
// OK

/**
 * Basic render: stateless functional component tests
 */
const C: React$StatelessFunctionalComponent<{}> = props => {};
const D: React$StatelessFunctionalComponent<{}> = props => {
  return;
};
const E: React$StatelessFunctionalComponent<{}> = props => {
  return null;
};

<C foo="bar" />;
// Error: \`React$StatelessFunctionalComponent\` must return \`React$Node\` which can't be undefined

<D foo="bar" />;
// Error: \`React$StatelessFunctionalComponent\` must return \`React$Node\` which can't be undefined

<E foo="bar" />;
// OK

type UnfixedPropsType = {|foo?: string|};

/**
 * PropsType inference: Class component test
 */
class F extends React.Component<UnfixedPropsType, void> {
  render = () => this.props.foo;
}
// Error: props.foo could be undefined

/**
 * PropsType inference: stateless functional component test
 */
const G: React$StatelessFunctionalComponent<UnfixedPropsType> = props => {
  return props.foo;
};
// Error: props.foo could be undefined

=====================================output=====================================
// @flow

import React from "react";

/**
 * Basic render: Class component tests
 */
class A extends React.Component<{}, void> {
  render = () => {};
}
class B extends React.Component<{}, void> {
  render = () => null;
}

<A />;
// Error: \`render\` should return a \`React$Node\` which can't be undefined

<B />;
// OK

/**
 * Basic render: stateless functional component tests
 */
const C: React$StatelessFunctionalComponent<{}> = (props) => {};
const D: React$StatelessFunctionalComponent<{}> = (props) => {
  return;
};
const E: React$StatelessFunctionalComponent<{}> = (props) => {
  return null;
};

<C foo="bar" />;
// Error: \`React$StatelessFunctionalComponent\` must return \`React$Node\` which can't be undefined

<D foo="bar" />;
// Error: \`React$StatelessFunctionalComponent\` must return \`React$Node\` which can't be undefined

<E foo="bar" />;
// OK

type UnfixedPropsType = {| foo?: string |};

/**
 * PropsType inference: Class component test
 */
class F extends React.Component<UnfixedPropsType, void> {
  render = () => this.props.foo;
}
// Error: props.foo could be undefined

/**
 * PropsType inference: stateless functional component test
 */
const G: React$StatelessFunctionalComponent<UnfixedPropsType> = (props) => {
  return props.foo;
};
// Error: props.foo could be undefined

================================================================================
`;

exports[`render_callback.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/* @flow */

const React = require('react');
const ReactDOM = require('react-dom');
const Example = React.createClass({
  propTypes: {
  },
  render() {
  	return <div>Hello</div>;
  }
});

ReactDOM.render(<Example/>, test$querySelector('#site'), () => {
	console.log('Rendered - arrow callback');
});

ReactDOM.render(<Example/>, test$querySelector('#site'), function() {
	console.log('Rendered - function callback');
});

// These should raise a warning
ReactDOM.render(<Example/>, test$querySelector('#site'), 1);
ReactDOM.render(<Example/>, test$querySelector('#site'), {});
ReactDOM.render(<Example/>, test$querySelector('#site'), '');
ReactDOM.render(<Example/>, test$querySelector('#site'), null);

=====================================output=====================================
/* @flow */

const React = require("react");
const ReactDOM = require("react-dom");
const Example = React.createClass({
  propTypes: {},
  render() {
    return <div>Hello</div>;
  },
});

ReactDOM.render(<Example />, test$querySelector("#site"), () => {
  console.log("Rendered - arrow callback");
});

ReactDOM.render(<Example />, test$querySelector("#site"), function () {
  console.log("Rendered - function callback");
});

// These should raise a warning
ReactDOM.render(<Example />, test$querySelector("#site"), 1);
ReactDOM.render(<Example />, test$querySelector("#site"), {});
ReactDOM.render(<Example />, test$querySelector("#site"), "");
ReactDOM.render(<Example />, test$querySelector("#site"), null);

================================================================================
`;

exports[`test-utils.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 */

import * as React from 'react';
import * as ReactDOM from 'react-dom';
import TestUtils from 'react-dom/test-utils';

class MyTestingComponent extends React.Component<{}> {
  render() {
    return <button className="my-button" />;
  }
}

const tree = TestUtils.renderIntoDocument(<MyTestingComponent />);
TestUtils.mockComponent(MyTestingComponent);
TestUtils.mockComponent(MyTestingComponent, 'span');
(TestUtils.isElement(<MyTestingComponent />): boolean);
(TestUtils.isElementOfType(
  <MyTestingComponent />,
  MyTestingComponent,
): boolean);
(TestUtils.findRenderedDOMComponentWithClass(tree, 'my-button'): ?Element);
(TestUtils.isDOMComponent(MyTestingComponent): boolean);
(TestUtils.isCompositeComponent(tree): boolean);
(TestUtils.isCompositeComponentWithType(tree, MyTestingComponent): boolean);
(TestUtils.findAllInRenderedTree(
  tree,
  child => child.tagName === 'BUTTON',
): Array<React.Component<any, any>>);
(TestUtils.scryRenderedDOMComponentsWithClass(
  tree,
  'my-button',
): Array<Element>);

const buttonEl = TestUtils.findRenderedDOMComponentWithClass(tree, 'my-button');
if (buttonEl != null) {
  TestUtils.Simulate.click(buttonEl);
}

(TestUtils.scryRenderedDOMComponentsWithTag(tree, 'button'): Array<Element>);
(TestUtils.findRenderedDOMComponentWithTag(tree, 'button'): ?Element);
(TestUtils.scryRenderedComponentsWithType(tree, MyTestingComponent): Array<
  React.Component<any, any>,
>);
(TestUtils.findRenderedComponentWithType(
  tree,
  MyTestingComponent,
): ?React.Component<any, any>);
TestUtils.act(() => {
  Math.random();
});
TestUtils.act(() => ({count: 123})); // error
async function runTest() {
  await TestUtils.act(async () => {
    // .. some test code
    await Promise.resolve();
  });
  /* // wishlist -
  act(async () => {
    // some test code
  }); // ideally this should error
  await act(() => {
    // ...
  }); // ideally this should error
  */
}

=====================================output=====================================
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 */

import * as React from "react";
import * as ReactDOM from "react-dom";
import TestUtils from "react-dom/test-utils";

class MyTestingComponent extends React.Component<{}> {
  render() {
    return <button className="my-button" />;
  }
}

const tree = TestUtils.renderIntoDocument(<MyTestingComponent />);
TestUtils.mockComponent(MyTestingComponent);
TestUtils.mockComponent(MyTestingComponent, "span");
(TestUtils.isElement(<MyTestingComponent />): boolean);
(TestUtils.isElementOfType(
  <MyTestingComponent />,
  MyTestingComponent
): boolean);
(TestUtils.findRenderedDOMComponentWithClass(tree, "my-button"): ?Element);
(TestUtils.isDOMComponent(MyTestingComponent): boolean);
(TestUtils.isCompositeComponent(tree): boolean);
(TestUtils.isCompositeComponentWithType(tree, MyTestingComponent): boolean);
(TestUtils.findAllInRenderedTree(
  tree,
  (child) => child.tagName === "BUTTON"
): Array<React.Component<any, any>>);
(TestUtils.scryRenderedDOMComponentsWithClass(
  tree,
  "my-button"
): Array<Element>);

const buttonEl = TestUtils.findRenderedDOMComponentWithClass(tree, "my-button");
if (buttonEl != null) {
  TestUtils.Simulate.click(buttonEl);
}

(TestUtils.scryRenderedDOMComponentsWithTag(tree, "button"): Array<Element>);
(TestUtils.findRenderedDOMComponentWithTag(tree, "button"): ?Element);
(TestUtils.scryRenderedComponentsWithType(tree, MyTestingComponent): Array<
  React.Component<any, any>
>);
(TestUtils.findRenderedComponentWithType(
  tree,
  MyTestingComponent
): ?React.Component<any, any>);
TestUtils.act(() => {
  Math.random();
});
TestUtils.act(() => ({ count: 123 })); // error
async function runTest() {
  await TestUtils.act(async () => {
    // .. some test code
    await Promise.resolve();
  });
  /* // wishlist -
  act(async () => {
    // some test code
  }); // ideally this should error
  await act(() => {
    // ...
  }); // ideally this should error
  */
}

================================================================================
`;

exports[`types_require.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

const React = require('react');

declare var node: React.Node; // OK: This is valid syntax.
declare var element: React.Element<any>; // OK: This is valid syntax.

=====================================output=====================================
// @flow

const React = require("react");

declare var node: React.Node; // OK: This is valid syntax.
declare var element: React.Element<any>; // OK: This is valid syntax.

================================================================================
`;

exports[`undefined_prop.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

import React from 'react';

class MyComponent extends React.Component<{title: string}> {}

<MyComponent title={undefined} />;

=====================================output=====================================
// @flow

import React from "react";

class MyComponent extends React.Component<{ title: string }> {}

<MyComponent title={undefined} />;

================================================================================
`;

exports[`useCallback_hook.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

import React from 'react';

{
  React.useCallback(); // Error: function requires another argument.
}

{
  const callback = React.useCallback(() => 123);
  const num: number = callback();
  const str: string = callback();// Error: number is incompatible with string.
}

{
  const callback = React.useCallback((num: number, str: string) => {
    (num: number);
    (str: string);
  });
  callback(123, 'abc'); // Ok
  callback(true); // Error: function requires another argument.
  callback('123', 'abc'); // Error: string is incompatible with number.
}

=====================================output=====================================
// @flow

import React from "react";

{
  React.useCallback(); // Error: function requires another argument.
}

{
  const callback = React.useCallback(() => 123);
  const num: number = callback();
  const str: string = callback(); // Error: number is incompatible with string.
}

{
  const callback = React.useCallback((num: number, str: string) => {
    (num: number);
    (str: string);
  });
  callback(123, "abc"); // Ok
  callback(true); // Error: function requires another argument.
  callback("123", "abc"); // Error: string is incompatible with number.
}

================================================================================
`;

exports[`useContext_hook.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

import React from 'react';

{
  React.useMutationEffect(); // Error: function requires another argument.
}

type CustomType = {|
  foo: string,
  bar: number,
|};

{
  let stringValue: string;
  let numericValue: number;
  let customValue: CustomType;

  const StringContext = React.createContext('hello');
  stringValue = React.useContext(StringContext); // Ok
  numericValue = React.useContext(StringContext); // Error: string is incompatible with number

  const InvalidContext: React$Context<CustomType> = React.createContext('hello'); // Error: inexact string is incompatible with exact CustomType

  const CustomContext: React$Context<CustomType> = React.createContext({
    foo: 'abc',
    bar: 123,
  });
  stringValue = React.useContext(CustomContext); // Error: CustomType is incompatible with string
  customValue = React.useContext(CustomContext); // Ok
}

{
  const Context = React.createContext(
    {foo: 0, bar: 0, baz: 0},
    (a, b) => {
      let result = 0;
      if (a.foo !== b.foo) {
        result |= 0b001;
      }
      if (a.bar !== b.bar) {
        result |= 0b010;
      }
      if (a.baz !== b.baz) {
        result |= 0b100;
      }
      return result;
    },
  );
  const {foo} = React.useContext(Context, 0b001);
  (foo: number); // Ok
  const {bar} = React.useContext(Context, 0b010);
  (bar: number); // Ok
  (bar: string); // Error: number is incompatible with string
}

=====================================output=====================================
// @flow

import React from "react";

{
  React.useMutationEffect(); // Error: function requires another argument.
}

type CustomType = {|
  foo: string,
  bar: number,
|};

{
  let stringValue: string;
  let numericValue: number;
  let customValue: CustomType;

  const StringContext = React.createContext("hello");
  stringValue = React.useContext(StringContext); // Ok
  numericValue = React.useContext(StringContext); // Error: string is incompatible with number

  const InvalidContext: React$Context<CustomType> = React.createContext(
    "hello"
  ); // Error: inexact string is incompatible with exact CustomType

  const CustomContext: React$Context<CustomType> = React.createContext({
    foo: "abc",
    bar: 123,
  });
  stringValue = React.useContext(CustomContext); // Error: CustomType is incompatible with string
  customValue = React.useContext(CustomContext); // Ok
}

{
  const Context = React.createContext({ foo: 0, bar: 0, baz: 0 }, (a, b) => {
    let result = 0;
    if (a.foo !== b.foo) {
      result |= 0b001;
    }
    if (a.bar !== b.bar) {
      result |= 0b010;
    }
    if (a.baz !== b.baz) {
      result |= 0b100;
    }
    return result;
  });
  const { foo } = React.useContext(Context, 0b001);
  (foo: number); // Ok
  const { bar } = React.useContext(Context, 0b010);
  (bar: number); // Ok
  (bar: string); // Error: number is incompatible with string
}

================================================================================
`;

exports[`useDebugValue_hook.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

import React from 'react';

const undefinedValue = React.useDebugValue(123);

(undefinedValue: typeof undefined); // Ok
(undefinedValue: string); // Error: undefined is incompatible with string

=====================================output=====================================
// @flow

import React from "react";

const undefinedValue = React.useDebugValue(123);

(undefinedValue: typeof undefined); // Ok
(undefinedValue: string); // Error: undefined is incompatible with string

================================================================================
`;

exports[`useEffect_hook.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

import React from 'react';

{
  React.useEffect(); // Error: function requires another argument.
}

{
  // Ok variants without cleanup functions
  React.useEffect(() => {});
  React.useEffect(() => {}, []);
  React.useEffect(() => {}, [1, 2, 3]);

  // Ok variants with cleanup functions
  React.useEffect(() => () => {});
  React.useEffect(() => () => {}, []);
  React.useEffect(() => () => {}, [1, 2, 3]);
}

{
  React.useEffect(1); // Error: number is incompatible with function type
  React.useEffect(() => {}, 1); // Error: number is incompatible with function react-only array
  React.useEffect(async () => {}) // Error: promise is incompatible with function return type
  React.useEffect(() => () => 123) // Error: cleanup function should not return a value
}

=====================================output=====================================
// @flow

import React from "react";

{
  React.useEffect(); // Error: function requires another argument.
}

{
  // Ok variants without cleanup functions
  React.useEffect(() => {});
  React.useEffect(() => {}, []);
  React.useEffect(() => {}, [1, 2, 3]);

  // Ok variants with cleanup functions
  React.useEffect(() => () => {});
  React.useEffect(() => () => {}, []);
  React.useEffect(() => () => {}, [1, 2, 3]);
}

{
  React.useEffect(1); // Error: number is incompatible with function type
  React.useEffect(() => {}, 1); // Error: number is incompatible with function react-only array
  React.useEffect(async () => {}); // Error: promise is incompatible with function return type
  React.useEffect(() => () => 123); // Error: cleanup function should not return a value
}

================================================================================
`;

exports[`useImperativeHandle_hook.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

import React from 'react';

{
  React.useImperativeHandle(); // Error: function requires another argument.
}

type Interface = {|
  focus: () => void
|};

{
  const api: Interface = {
    focus: () => {}
  };

  const ref: {current: null | Interface } = React.createRef();
  React.useImperativeHandle(ref, () => api); // Ok

  const refSetter = (instance: null | Interface) => {};
  React.useImperativeHandle(refSetter, () => api); // Ok
}

{
  const api: Interface = {
    focus: () => {}
  };

  const ref: {current: null | Interface } = React.createRef();
  React.useImperativeHandle(ref, () => ({})); // Error: inexact object literal is incompatible with exact Interface

  const refSetter = (instance: null | Interface) => {};
  React.useImperativeHandle(refSetter, () => ({})); // Error: inexact object literal is incompatible with exact Interface
}

=====================================output=====================================
// @flow

import React from "react";

{
  React.useImperativeHandle(); // Error: function requires another argument.
}

type Interface = {|
  focus: () => void,
|};

{
  const api: Interface = {
    focus: () => {},
  };

  const ref: { current: null | Interface } = React.createRef();
  React.useImperativeHandle(ref, () => api); // Ok

  const refSetter = (instance: null | Interface) => {};
  React.useImperativeHandle(refSetter, () => api); // Ok
}

{
  const api: Interface = {
    focus: () => {},
  };

  const ref: { current: null | Interface } = React.createRef();
  React.useImperativeHandle(ref, () => ({})); // Error: inexact object literal is incompatible with exact Interface

  const refSetter = (instance: null | Interface) => {};
  React.useImperativeHandle(refSetter, () => ({})); // Error: inexact object literal is incompatible with exact Interface
}

================================================================================
`;

exports[`useLayoutEffect_hook.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

import React from 'react';

{
  React.useLayoutEffect(); // Error: function requires another argument.
}

{
  // Ok variants without cleanup functions
  React.useLayoutEffect(() => {});
  React.useLayoutEffect(() => {}, []);
  React.useLayoutEffect(() => {}, [1, 2, 3]);

  // Ok variants with cleanup functions
  React.useLayoutEffect(() => () => {});
  React.useLayoutEffect(() => () => {}, []);
  React.useLayoutEffect(() => () => {}, [1, 2, 3]);
}

{
  React.useLayoutEffect(1); // Error: number is incompatible with function type
  React.useLayoutEffect(() => {}, 1); // Error: number is incompatible with function react-only array
  React.useLayoutEffect(async () => {}) // Error: promise is incompatible with function return type
  React.useLayoutEffect(() => () => 123) // Error: cleanup function should not return a value
}

=====================================output=====================================
// @flow

import React from "react";

{
  React.useLayoutEffect(); // Error: function requires another argument.
}

{
  // Ok variants without cleanup functions
  React.useLayoutEffect(() => {});
  React.useLayoutEffect(() => {}, []);
  React.useLayoutEffect(() => {}, [1, 2, 3]);

  // Ok variants with cleanup functions
  React.useLayoutEffect(() => () => {});
  React.useLayoutEffect(() => () => {}, []);
  React.useLayoutEffect(() => () => {}, [1, 2, 3]);
}

{
  React.useLayoutEffect(1); // Error: number is incompatible with function type
  React.useLayoutEffect(() => {}, 1); // Error: number is incompatible with function react-only array
  React.useLayoutEffect(async () => {}); // Error: promise is incompatible with function return type
  React.useLayoutEffect(() => () => 123); // Error: cleanup function should not return a value
}

================================================================================
`;

exports[`useMemo_hook.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

import React from 'react';

{
  React.useMemo(); // Error: function requires another argument.
}

{
  let numeric: number;
  numeric = React.useMemo(() => 1); // Ok
  numeric = React.useMemo(() => 1, []); // Ok
  numeric = React.useMemo(() => 1, [1, 2, 3]); // Ok
}

{
  const invalid: number = React.useMemo(() => "abc"); // Error: string is incompatible with number
}

=====================================output=====================================
// @flow

import React from "react";

{
  React.useMemo(); // Error: function requires another argument.
}

{
  let numeric: number;
  numeric = React.useMemo(() => 1); // Ok
  numeric = React.useMemo(() => 1, []); // Ok
  numeric = React.useMemo(() => 1, [1, 2, 3]); // Ok
}

{
  const invalid: number = React.useMemo(() => "abc"); // Error: string is incompatible with number
}

================================================================================
`;

exports[`useMutationEffect_hook.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

import React from 'react';

{
  React.useMutationEffect(); // Error: function requires another argument.
}

{
  // Ok variants without cleanup functions
  React.useMutationEffect(() => {});
  React.useMutationEffect(() => {}, []);
  React.useMutationEffect(() => {}, [1, 2, 3]);

  // Ok variants with cleanup functions
  React.useMutationEffect(() => () => {});
  React.useMutationEffect(() => () => {}, []);
  React.useMutationEffect(() => () => {}, [1, 2, 3]);
}

{
  React.useMutationEffect(1); // Error: number is incompatible with function type
  React.useMutationEffect(() => {}, 1); // Error: number is incompatible with function react-only array
}

=====================================output=====================================
// @flow

import React from "react";

{
  React.useMutationEffect(); // Error: function requires another argument.
}

{
  // Ok variants without cleanup functions
  React.useMutationEffect(() => {});
  React.useMutationEffect(() => {}, []);
  React.useMutationEffect(() => {}, [1, 2, 3]);

  // Ok variants with cleanup functions
  React.useMutationEffect(() => () => {});
  React.useMutationEffect(() => () => {}, []);
  React.useMutationEffect(() => () => {}, [1, 2, 3]);
}

{
  React.useMutationEffect(1); // Error: number is incompatible with function type
  React.useMutationEffect(() => {}, 1); // Error: number is incompatible with function react-only array
}

================================================================================
`;

exports[`useReducer_hook.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

import React from 'react';

{
  React.useReducer(); // Error: function requires another argument.
}

function reducer(state, action) {
  switch (action.type) {
    case "reset":
      return { count: action.payload };
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      return state;
  }
}

const initialState = { count: 0 };

{
  const [state, dispatch] = React.useReducer(reducer, initialState);
  (state.count: number); // Ok
  (state.count: string); // Error: number is incompatible with string

  dispatch({ type: "reset", payload: 123 });
  dispatch({ type: "increment" });
  dispatch({ type: "decrement" });
}

{
  function init(initialArg){
    return {
      count: initialArg.initial
    }
  }

  const [state, dispatch] = React.useReducer(reducer, { initial: 123 }, init);
  (state.count: number); // Ok

  dispatch({ type: "reset", payload: 123 });
  dispatch({ type: "increment" });
  dispatch({ type: "decrement" });
}

=====================================output=====================================
// @flow

import React from "react";

{
  React.useReducer(); // Error: function requires another argument.
}

function reducer(state, action) {
  switch (action.type) {
    case "reset":
      return { count: action.payload };
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      return state;
  }
}

const initialState = { count: 0 };

{
  const [state, dispatch] = React.useReducer(reducer, initialState);
  (state.count: number); // Ok
  (state.count: string); // Error: number is incompatible with string

  dispatch({ type: "reset", payload: 123 });
  dispatch({ type: "increment" });
  dispatch({ type: "decrement" });
}

{
  function init(initialArg) {
    return {
      count: initialArg.initial,
    };
  }

  const [state, dispatch] = React.useReducer(reducer, { initial: 123 }, init);
  (state.count: number); // Ok

  dispatch({ type: "reset", payload: 123 });
  dispatch({ type: "increment" });
  dispatch({ type: "decrement" });
}

================================================================================
`;

exports[`useRef_hook.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

import React from 'react';

class Foo extends React.Component<{}, void> {}
class Bar extends React.Component<{}, void> {}

{
  const stringValue: {current: string} = React.useRef("abc"); // Ok
  const numberValue: {current: number} = React.useRef(123); // Ok
  const booleanValue: {current: boolean} = React.useRef(true); // Ok
  const nullValue: {current: null} = React.useRef(null); // Ok
}

{
  const stringValue: {current: string | null} = React.useRef(123); // Error: number is incompatible with string in property current
  const numberValue: {current: number | null} = React.useRef("abc"); // Error: string is incompatible with number in property current
  const nullValue: {current: null} = React.useRef(true); // Error: boolean is incompatible with null in property current
}

{
  const stringValue: {current: string | null} = React.useRef(null);
  stringValue.current = "foo"; // Ok
  stringValue.current = 123; // Error: number is incompatible with string in property current
}

{
  const foo: {current: Foo | null} = React.useRef(new Foo()); // Ok
}

{
  const foo: {current: Foo | null} = React.useRef(new Bar()); // Error: Bar is incompatible with Foo in property current
}

=====================================output=====================================
// @flow

import React from "react";

class Foo extends React.Component<{}, void> {}
class Bar extends React.Component<{}, void> {}

{
  const stringValue: { current: string } = React.useRef("abc"); // Ok
  const numberValue: { current: number } = React.useRef(123); // Ok
  const booleanValue: { current: boolean } = React.useRef(true); // Ok
  const nullValue: { current: null } = React.useRef(null); // Ok
}

{
  const stringValue: { current: string | null } = React.useRef(123); // Error: number is incompatible with string in property current
  const numberValue: { current: number | null } = React.useRef("abc"); // Error: string is incompatible with number in property current
  const nullValue: { current: null } = React.useRef(true); // Error: boolean is incompatible with null in property current
}

{
  const stringValue: { current: string | null } = React.useRef(null);
  stringValue.current = "foo"; // Ok
  stringValue.current = 123; // Error: number is incompatible with string in property current
}

{
  const foo: { current: Foo | null } = React.useRef(new Foo()); // Ok
}

{
  const foo: { current: Foo | null } = React.useRef(new Bar()); // Error: Bar is incompatible with Foo in property current
}

================================================================================
`;

exports[`useState_hook.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

import React from 'react';

React.useState(); // Error: function requires another argument.

const [count, setCount] = React.useState<number>(1);

(count: number); // Ok
(count: string); // Error: number is incompatible with string

setCount(2); // Okay
setCount(true); // Error: boolean is incompatible with number

=====================================output=====================================
// @flow

import React from "react";

React.useState(); // Error: function requires another argument.

const [count, setCount] = React.useState<number>(1);

(count: number); // Ok
(count: string); // Error: number is incompatible with string

setCount(2); // Okay
setCount(true); // Error: boolean is incompatible with number

================================================================================
`;
