// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`dict.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

function foo(map: { [key: string]: mixed }) {
  const first = { some: "hello" };
  const options = { some: 42  };
  return Object.assign (
    {
      first,
      ...map // Error, can't spread indexer second
    },
    options
  );
}

=====================================output=====================================
// @flow

function foo(map: { [key: string]: mixed }) {
  const first = { some: "hello" };
  const options = { some: 42 };
  return Object.assign(
    {
      first,
      ...map, // Error, can't spread indexer second
    },
    options
  );
}

================================================================================
`;

exports[`exact.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

type Foo = {|
  bar: string,
  baz: number,
|};

const foo = {bar: 'hello', baz: 123};
const other = {bar: 'wat'}

const spread: Foo = {...foo, ...other};

const foo_inexact: { baz: number } = { bar: 42, baz: 123 };
const spread_inexact_first: Foo = {...foo_inexact, ...other}; // not OK
const spread_inexact_second: Foo = {...other, ...foo_inexact}; // not OK

=====================================output=====================================
// @flow

type Foo = {|
  bar: string,
  baz: number,
|};

const foo = { bar: "hello", baz: 123 };
const other = { bar: "wat" };

const spread: Foo = { ...foo, ...other };

const foo_inexact: { baz: number } = { bar: 42, baz: 123 };
const spread_inexact_first: Foo = { ...foo_inexact, ...other }; // not OK
const spread_inexact_second: Foo = { ...other, ...foo_inexact }; // not OK

================================================================================
`;

exports[`issue_4152.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

/**
 * This regression test exercises a bug reported
 * in https://github.com/facebook/flow/issues/4152
 */

export function wrapAndFlatten<T>(arr: Array<T>) {
  const mapped = arr.map((n: T) => {
    return [n];
  });
  return mapped.reduce((x, y) => [...x, ...y]);
};

=====================================output=====================================
// @flow

/**
 * This regression test exercises a bug reported
 * in https://github.com/facebook/flow/issues/4152
 */

export function wrapAndFlatten<T>(arr: Array<T>) {
  const mapped = arr.map((n: T) => {
    return [n];
  });
  return mapped.reduce((x, y) => [...x, ...y]);
}

================================================================================
`;

exports[`jsx.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow
const React = require('react');

type Props = $ReadOnly<{| bar: string, baz: number |}>;
declare var TestComponent: React.ComponentType<Props>;
const props: Props = {bar: '', baz: 0};

<TestComponent {...props} />; //breaks
({...props}: Props); //works

=====================================output=====================================
// @flow
const React = require("react");

type Props = $ReadOnly<{| bar: string, baz: number |}>;
declare var TestComponent: React.ComponentType<Props>;
const props: Props = { bar: "", baz: 0 };

<TestComponent {...props} />; //breaks
({ ...props }: Props); //works

================================================================================
`;

exports[`lit_reason.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
//@flow

declare function test(): {| foo: number |};
const y: {foo: number | string} = {...test()}; // Should not error

=====================================output=====================================
//@flow

declare function test(): {| foo: number |};
const y: { foo: number | string } = { ...test() }; // Should not error

================================================================================
`;

exports[`null.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

function foo() {
  const bar = null;
  const empty = {...bar};
  (empty.x); // Error
}

=====================================output=====================================
// @flow

function foo() {
  const bar = null;
  const empty = { ...bar };
  empty.x; // Error
}

================================================================================
`;

exports[`test.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
function parseTimestamp(timestamp: string): number {
    return 0;
}

function parseCounter(line: string): number {
    return 0;
}

function parseGroup(lines: Array<string>): {
    counter: number;
    begin: number;
    end: number;
    text: string;
} {
    var counter = parseCounter(lines[0]);
    var timeframe = parseTimeframe(lines[1]);
    return {
        counter,
        ...timeframe,
        text: lines[2]
    };
}

function parseTimeframe(line: string): {| begin: number; end: number |} {
    var timestamps = line.split('-->');
    return {
        begin: parseTimestamp(timestamps[0].trim()),
        end: parseTimestamp(timestamps[1].trim())
    };
}

=====================================output=====================================
function parseTimestamp(timestamp: string): number {
  return 0;
}

function parseCounter(line: string): number {
  return 0;
}

function parseGroup(
  lines: Array<string>
): {
  counter: number,
  begin: number,
  end: number,
  text: string,
} {
  var counter = parseCounter(lines[0]);
  var timeframe = parseTimeframe(lines[1]);
  return {
    counter,
    ...timeframe,
    text: lines[2],
  };
}

function parseTimeframe(line: string): {| begin: number, end: number |} {
  var timestamps = line.split("-->");
  return {
    begin: parseTimestamp(timestamps[0].trim()),
    end: parseTimestamp(timestamps[1].trim()),
  };
}

================================================================================
`;

exports[`test2.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/**
 * @flow
 */

function foo(o) {
    bar({...o});
}
function bar(_: {foo:number}) { }
foo({foo: 42});

=====================================output=====================================
/**
 * @flow
 */

function foo(o) {
  bar({ ...o });
}
function bar(_: { foo: number }) {}
foo({ foo: 42 });

================================================================================
`;

exports[`test3.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
var p = { y: "" };
var q = { z: "" };
var o = {
  x: 5,
  ...p,
  ...q,
};
var y: number = o.y; // Error string ~> number
var z: number = o.z; // Error string ~> number

// test conflicting keys (they get overwritten)
var r = { y: 123 };
var s = {
  ...p,
  ...r,
};
var t: number = s.y;

=====================================output=====================================
var p = { y: "" };
var q = { z: "" };
var o = {
  x: 5,
  ...p,
  ...q,
};
var y: number = o.y; // Error string ~> number
var z: number = o.z; // Error string ~> number

// test conflicting keys (they get overwritten)
var r = { y: 123 };
var s = {
  ...p,
  ...r,
};
var t: number = s.y;

================================================================================
`;

exports[`test4.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/* @flow */
function test(...nums: Array<number>) {}

test(0, ...[1, 2, 3]);

=====================================output=====================================
/* @flow */
function test(...nums: Array<number>) {}

test(0, ...[1, 2, 3]);

================================================================================
`;

exports[`test5.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/* @flow */

declare function map<Tv, TNext>(
  obj: {[key: string]: Tv},
  iterator:((obj: Tv) => TNext),
): Array<TNext>;

/**
 * Tests overriding a property via a spread, where the value is a tvar. the
 * type of the prop from the object that is being overridden (\`x.kind\` in the
 * case below) should //not// feed back into the tvar (\`value\`), since the
 * result is a new object.
 */
function test(
  x: {kind: ?string},
  kinds: {[key: string]: string}
): Array<{kind: ?string}> {
  return map(kinds, (value) => {
    (value: string); // OK
    return {
      ...x,
      kind: value,
    };
  });
}

=====================================output=====================================
/* @flow */

declare function map<Tv, TNext>(
  obj: { [key: string]: Tv },
  iterator: (obj: Tv) => TNext
): Array<TNext>;

/**
 * Tests overriding a property via a spread, where the value is a tvar. the
 * type of the prop from the object that is being overridden (\`x.kind\` in the
 * case below) should //not// feed back into the tvar (\`value\`), since the
 * result is a new object.
 */
function test(
  x: { kind: ?string },
  kinds: { [key: string]: string }
): Array<{ kind: ?string }> {
  return map(kinds, (value) => {
    (value: string); // OK
    return {
      ...x,
      kind: value,
    };
  });
}

================================================================================
`;

exports[`test6.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
var o = {
  foo: 'bar'
};
o = {...o};
(o: {foo: string});

var p = {
  foo: 'bar'
};
(p: {foo: string; abc: string}); // error, p doesn't have \`abc\` yet
p = {...p, abc: 'def'};
(p: {foo: string; abc: string});

var q = {
  foo: 'bar'
};
for (var i = 0; i < 10; i++) {
  q = {...q};
}
(q: {foo: string});

=====================================output=====================================
var o = {
  foo: "bar",
};
o = { ...o };
(o: { foo: string });

var p = {
  foo: "bar",
};
(p: { foo: string, abc: string }); // error, p doesn't have \`abc\` yet
p = { ...p, abc: "def" };
(p: { foo: string, abc: string });

var q = {
  foo: "bar",
};
for (var i = 0; i < 10; i++) {
  q = { ...q };
}
(q: { foo: string });

================================================================================
`;

exports[`test7.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

let tests = [
  function(x: Object) {
    ({...x}: Object);
    ({...x}: void); // error, Object
  },
];

=====================================output=====================================
// @flow

let tests = [
  function (x: Object) {
    ({ ...x }: Object);
    ({ ...x }: void); // error, Object
  },
];

================================================================================
`;

exports[`test8.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/* Test to ensure that spreads of intersections wait until every member is
 * resolved before the spread resolves to a result. */

type O = A & B;
declare var o: O;
({ ...o }: { p: number, q: string }); // OK
({ ...o }: { p: number, q: number }); // error: string ~> number (prop q)
({ ...o }: { p: string, q: string }); // error: number ~> string (prop p)

// types declared below, so they resolve after the spread is processed
type A = { p: number };
type B = { q: string };

=====================================output=====================================
/* Test to ensure that spreads of intersections wait until every member is
 * resolved before the spread resolves to a result. */

type O = A & B;
declare var o: O;
({ ...o }: { p: number, q: string }); // OK
({ ...o }: { p: number, q: number }); // error: string ~> number (prop q)
({ ...o }: { p: string, q: string }); // error: number ~> string (prop p)

// types declared below, so they resolve after the spread is processed
type A = { p: number };
type B = { q: string };

================================================================================
`;

exports[`test9.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
interface I_call {
  (): void;
}
declare var o_call: I_call;
({ ...o_call }: { "$call": any }); // error: interfaces cannot be spread 

interface I_index {
  [string]: number;
}
declare var o_index: I_index;
({ ...o_index }: { "$key": any }); // error: interfaces cannot be spread 
({ ...o_index }: { "$value": any }); // error: interfaces cannot be spread 

=====================================output=====================================
interface I_call {
  (): void;
}
declare var o_call: I_call;
({ ...o_call }: { $call: any }); // error: interfaces cannot be spread

interface I_index {
  [string]: number;
}
declare var o_index: I_index;
({ ...o_index }: { $key: any }); // error: interfaces cannot be spread
({ ...o_index }: { $value: any }); // error: interfaces cannot be spread

================================================================================
`;

exports[`test10.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
var x = null;
var o = { p: 0, ...x };
(o.p: empty); // error: number ~> empty

=====================================output=====================================
var x = null;
var o = { p: 0, ...x };
(o.p: empty); // error: number ~> empty

================================================================================
`;

exports[`unsealed.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

function foo1(b: bool): {| x?: number |} {
  var o = {};
  if (b) { o.x = 0; }
  return o; // error, unsealed implies inexact
}

function foo2(b: bool): { x?: number } {
  var o = {};
  if (b) { o.x = 0; }
  return o; // OK
}

function bar() {
  const a = { x: 42 };
  const b1 = {
    ...a,
    ...foo1(true), // must be exact, but runs into restrictions upstream
  };
  const b2 = {
    ...foo2(true), // may be inexact, so workaround for above
    ...a,
  };
  (b2.x: string); // expected error: number ~/~> string
}

=====================================output=====================================
// @flow

function foo1(b: boolean): {| x?: number |} {
  var o = {};
  if (b) {
    o.x = 0;
  }
  return o; // error, unsealed implies inexact
}

function foo2(b: boolean): { x?: number } {
  var o = {};
  if (b) {
    o.x = 0;
  }
  return o; // OK
}

function bar() {
  const a = { x: 42 };
  const b1 = {
    ...a,
    ...foo1(true), // must be exact, but runs into restrictions upstream
  };
  const b2 = {
    ...foo2(true), // may be inexact, so workaround for above
    ...a,
  };
  (b2.x: string); // expected error: number ~/~> string
}

================================================================================
`;
