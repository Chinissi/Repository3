// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`intersection-function.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/**
 * @format
 * @flow
 */

class X {
  p: number;
}
class Y {
  p: number;
}
class Z {}
class W<T> {
  p: T;
}

declare function a(x: number): void;
declare function a(x: string): void;
a(true);

declare function b(x: string): void;
declare function b(x: {p: string}): void;
b(42);
b({p: 42});

declare function c(x: string): void;
declare function c(x: {a: {b: string}}): void;
declare function c(x: boolean): void;
declare function c(x: {a: {b: boolean}}): void;
c(42);
c({a: {b: 42}});

declare function d(x: string): void;
declare function d(x: {a: string}): void;
declare function d(x: {a: {b: string}}): void;
d(42);
d({a: 42});
d({a: {b: 42}});

declare function e(x: X): void;
declare function e(x: {p: string}): void;
e(42);
e(new X());
e(new Y());
e(new Z());
e({p: true});

declare function f(x: {p: string}): void;
declare function f(x: $ReadOnlyArray<string>): void;
declare function f(x: [string, string]): void;
f(42);
f({p: 42});
f({});
f(new Y());
f(new Z());
f(([1]: [number]));
f(([1, 2]: [number, number]));
f(([1, 2, 3]: [number, number, number]));
f(((null: any): Array<number> & {p: number}));

declare function g(x: string): void;
declare function g(x: Z): void;
g(42);
g({});

declare function h(a: string, b: string): void;
declare function h(a: number, b: {}, c: string): void;
h(1, 2, 3);

declare function i(a: Y, b: string): void;
declare function i(a: X, b: number): void;
i(new Y(), 42);

declare function j(a: number, b: string): void;
declare function j(a: string, b: number): void;
j(1, 2);

declare function k(a: number, b: {p: string}): void;
declare function k(a: string, b: {p: number}): void;
k(1, {p: 2});

declare function m(x: W<string>): void;
declare function m(x: {p: string}): void;
m((new W(): W<number>));

=====================================output=====================================
/**
 * @format
 * @flow
 */

class X {
  p: number;
}
class Y {
  p: number;
}
class Z {}
class W<T> {
  p: T;
}

declare function a(x: number): void;
declare function a(x: string): void;
a(true);

declare function b(x: string): void;
declare function b(x: { p: string }): void;
b(42);
b({ p: 42 });

declare function c(x: string): void;
declare function c(x: { a: { b: string } }): void;
declare function c(x: boolean): void;
declare function c(x: { a: { b: boolean } }): void;
c(42);
c({ a: { b: 42 } });

declare function d(x: string): void;
declare function d(x: { a: string }): void;
declare function d(x: { a: { b: string } }): void;
d(42);
d({ a: 42 });
d({ a: { b: 42 } });

declare function e(x: X): void;
declare function e(x: { p: string }): void;
e(42);
e(new X());
e(new Y());
e(new Z());
e({ p: true });

declare function f(x: { p: string }): void;
declare function f(x: $ReadOnlyArray<string>): void;
declare function f(x: [string, string]): void;
f(42);
f({ p: 42 });
f({});
f(new Y());
f(new Z());
f(([1]: [number]));
f(([1, 2]: [number, number]));
f(([1, 2, 3]: [number, number, number]));
f(((null: any): Array<number> & { p: number }));

declare function g(x: string): void;
declare function g(x: Z): void;
g(42);
g({});

declare function h(a: string, b: string): void;
declare function h(a: number, b: {}, c: string): void;
h(1, 2, 3);

declare function i(a: Y, b: string): void;
declare function i(a: X, b: number): void;
i(new Y(), 42);

declare function j(a: number, b: string): void;
declare function j(a: string, b: number): void;
j(1, 2);

declare function k(a: number, b: { p: string }): void;
declare function k(a: string, b: { p: number }): void;
k(1, { p: 2 });

declare function m(x: W<string>): void;
declare function m(x: { p: string }): void;
m((new W(): W<number>));

================================================================================
`;

exports[`sentinel.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/**
 * @format
 * @flow
 */

type X =
  | {type: 'A', p: number}
  | {type: 'B', p: string}
  | {type: 'C', p: boolean};

({type: 'A', p: 'foo'}: X);
({type: 'D'}: X);

=====================================output=====================================
/**
 * @format
 * @flow
 */

type X =
  | { type: "A", p: number }
  | { type: "B", p: string }
  | { type: "C", p: boolean };

({ type: "A", p: "foo" }: X);
({ type: "D" }: X);

================================================================================
`;

exports[`union.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/**
 * @format
 * @flow
 */

class X {
  p: number;
}
class Y {
  p: number;
}
class Z {}
class W<T> {
  p: T;
}

type A = number | string;
(true: A);

type B = string | {p: string};
(42: B);
({p: 42}: B);

type C = string | {a: {b: string}} | boolean | {a: {b: boolean}};
(42: C);
({a: {b: 42}}: C);

type D = string | {a: string} | {a: {b: string}};
(42: D);
({a: 42}: D);
({a: {b: 42}}: D);

type E = X | {p: string};
(42: E);
(new X(): E);
(new Y(): E);
(new Z(): E);
({p: true}: E);

type F = {p: string} | $ReadOnlyArray<string> | [string, string];
(42: F);
({p: 42}: F);
({}: F);
(new Y(): F);
(new Z(): F);
(([1]: [number]): F);
(([1, 2]: [number, number]): F);
(([1, 2, 3]: [number, number, number]): F);
(((null: any): Array<number> & {p: number}): F);

type G = string | Z;
(42: G);
({}: G);

type M = W<string> | {p: string};
((new W(): W<number>): M);

=====================================output=====================================
/**
 * @format
 * @flow
 */

class X {
  p: number;
}
class Y {
  p: number;
}
class Z {}
class W<T> {
  p: T;
}

type A = number | string;
(true: A);

type B = string | { p: string };
(42: B);
({ p: 42 }: B);

type C = string | { a: { b: string } } | boolean | { a: { b: boolean } };
(42: C);
({ a: { b: 42 } }: C);

type D = string | { a: string } | { a: { b: string } };
(42: D);
({ a: 42 }: D);
({ a: { b: 42 } }: D);

type E = X | { p: string };
(42: E);
(new X(): E);
(new Y(): E);
(new Z(): E);
({ p: true }: E);

type F = { p: string } | $ReadOnlyArray<string> | [string, string];
(42: F);
({ p: 42 }: F);
({}: F);
(new Y(): F);
(new Z(): F);
(([1]: [number]): F);
(([1, 2]: [number, number]): F);
(([1, 2, 3]: [number, number, number]): F);
(((null: any): Array<number> & { p: number }): F);

type G = string | Z;
(42: G);
({}: G);

type M = W<string> | { p: string };
((new W(): W<number>): M);

================================================================================
`;
