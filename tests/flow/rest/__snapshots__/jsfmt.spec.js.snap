// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`type.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

declare opaque type X;
declare opaque type Y;
declare var x: X;
declare var y: Y;

type O1 = $Rest<{|x: X, y: Y|}, {|y: Y|}>;
declare var o1: O1;
(o1: {||}); // Error: missing x
(o1: {|x: X|}); // OK
(o1: {|x?: X|}); // Error: x is not optional
(o1: {|x: X, y?: Y|}); // Error: y is not in O1
(o1: {|x?: X, y?: Y|}); // Error: x is not optional and y is not in O1
(o1: {|x: Y|}); // Error: X = Y
({y}: O1); // Error: missing x
({x}: O1); // OK
({x, y}: O1); // Error: y is not in O1
({x: y}: O1); // Error: Y ~> X

type O2 = $Rest<{|x: X, y: Y|}, {|y: X|}>;
declare var o2: O2;
(o2: {|x: X|}); // Error: Y ~> X

type O3 = $Rest<{|x: X, y: Y|}, {y: Y}>;
declare var o3: O3;
(o3: {||}); // Error: missing x and y
(o3: {|x: X|}); // Error: x is optional and missing y
(o3: {|x?: X|}); // Error: missing y
(o3: {|x: X, y?: Y|}); // Error: x is optional
(o3: {|x?: X, y?: Y|}); // OK
(o3: {|x: Y|}); // Error: X = Y, x is optional, and missing y
({}: O3); // OK
({x}: O3); // OK
({x, y}: O3); // OK
({x: y}: O3); // Error: Y ~> X

type O4 = $Rest<{|x: X, y: Y|}, {|y?: Y|}>;
declare var o4: O4;
(o4: {||}); // Error: missing x and y
(o4: {|x: X|}); // Error: missing y
(o4: {|x?: X|}); // Error: x is not optional and missing y
(o4: {|x: X, y?: Y|}); // OK
(o4: {|x?: X, y?: Y|}); // Error: x is not optional
(o4: {|x: Y|}); // Error: X = Y, and missing y
({y}: O4); // Error: missing x
({x}: O4); // OK
({x, y}: O4); // OK
({x: y}: O4); // Error: Y ~> X

type O5 = $Rest<{x: X, y: Y}, {|y: Y|}>;
declare var o5: O5;
(o5: {|x?: X|}); // Error: inexact ~> exact
(o5: {}); // OK
(o5: {x: X}); // Error: x is optional
(o5: {x?: X}); // OK
(o5: {x: X, y?: Y}); // Error: x is optional and y is not in O5
(o5: {x?: X, y?: Y}); // Error: y is not in O5
(o5: {x: Y}); // Error: x is optional and X = Y
({}: O5); // OK
({x}: O5); // OK
({x, y}: O5); // OK
({x: y}: O5); // Error: Y ~> X

type O6 = $Rest<{x: X, y: Y}, {y: Y}>;
declare var o6: O6;
(o6: {|x?: X, y?: Y|}); // Error: inexact ~> exact
(o6: {}); // OK
(o6: {x: X}); // Error: x is optional
(o6: {x?: X}); // OK
(o6: {x: X, y?: Y}); // Error: x is optional
(o6: {x?: X, y?: Y}); // OK
(o6: {x: Y}); // Error: X = Y, x is optional
({}: O6); // OK
({x}: O6); // OK
({x, y}: O6); // OK
({x: y}: O6); // Error: Y ~> X

type O7 = $Rest<{x: X, y: Y}, {|y?: Y|}>;
declare var o7: O7;
(o7: {|x?: X, y?: Y|}); // Error: inexact ~> exact
(o7: {}); // OK
(o7: {x: X}); // Error: x is optional
(o7: {x?: X}); // OK
(o7: {x: X, y?: Y}); // Error: x is optional
(o7: {x?: X, y?: Y}); // OK
(o7: {x: Y}); // Error: X = Y and x is optional
({}: O7); // OK
({x}: O7); // OK
({x, y}: O7); // OK
({x: y}: O7); // Error: Y ~> X

type O8 = $Rest<{x: X, y: Y}, {|y: X|}>; // Error: Y ~> X
declare var o8: O8;
(o8: {x?: X}); // OK

type O9 = $Rest<{|x: X, y: Y|}, {y: X}>; // Error: Y ~> X
declare var o9: O9;
(o9: {|x?: X, y?: Y|}); // OK

type O10 = $Rest<{|x: X, y: Y|}, {|y?: X|}>; // Error: Y ~> X
declare var o10: O10;
(o10: {|x: X, y?: Y|}); // OK

type O11 = $Rest<{|x: X, y?: Y|}, {|y: Y|}>; // Error: void ~> Y
declare var o11: O11;
(o11: {|x: X|}); // OK

type O12 = $Rest<{|x: X|}, {|y: Y|}>; // Error: void ~> Y
declare var o12: O12;
(o12: {|x: X|}); // OK

type O13 = $Rest<{|x: X, y?: Y|}, {|y: Y | void|}>;
declare var o13: O13;
(o13: {|x: X|}); // OK

type O14 = $Rest<{|x: X|}, {|y: Y | void|}>;
declare var o14: O14;
(o14: {|x: X|}); // OK

type O15 = $Rest<{|x: X, y: Y|}, {|y?: Y|}>;
declare var o15: O15;
(o15: {|x: X, y?: Y|}); // OK

type O16 = $Rest<{|x: X, y: Y|}, {y: Y}>;
declare var o16: O16;
(o16: {|x?: X, y?: Y|}); // OK

type O17 = $Rest<{|x: X, y?: Y|}, {|y?: Y|}>;
declare var o17: O17;
(o17: {|x: X, y?: Y|}); // OK

=====================================output=====================================
// @flow

declare opaque type X;
declare opaque type Y;
declare var x: X;
declare var y: Y;

type O1 = $Rest<{| x: X, y: Y |}, {| y: Y |}>;
declare var o1: O1;
(o1: {||}); // Error: missing x
(o1: {| x: X |}); // OK
(o1: {| x?: X |}); // Error: x is not optional
(o1: {| x: X, y?: Y |}); // Error: y is not in O1
(o1: {| x?: X, y?: Y |}); // Error: x is not optional and y is not in O1
(o1: {| x: Y |}); // Error: X = Y
({ y }: O1); // Error: missing x
({ x }: O1); // OK
({ x, y }: O1); // Error: y is not in O1
({ x: y }: O1); // Error: Y ~> X

type O2 = $Rest<{| x: X, y: Y |}, {| y: X |}>;
declare var o2: O2;
(o2: {| x: X |}); // Error: Y ~> X

type O3 = $Rest<{| x: X, y: Y |}, { y: Y }>;
declare var o3: O3;
(o3: {||}); // Error: missing x and y
(o3: {| x: X |}); // Error: x is optional and missing y
(o3: {| x?: X |}); // Error: missing y
(o3: {| x: X, y?: Y |}); // Error: x is optional
(o3: {| x?: X, y?: Y |}); // OK
(o3: {| x: Y |}); // Error: X = Y, x is optional, and missing y
({}: O3); // OK
({ x }: O3); // OK
({ x, y }: O3); // OK
({ x: y }: O3); // Error: Y ~> X

type O4 = $Rest<{| x: X, y: Y |}, {| y?: Y |}>;
declare var o4: O4;
(o4: {||}); // Error: missing x and y
(o4: {| x: X |}); // Error: missing y
(o4: {| x?: X |}); // Error: x is not optional and missing y
(o4: {| x: X, y?: Y |}); // OK
(o4: {| x?: X, y?: Y |}); // Error: x is not optional
(o4: {| x: Y |}); // Error: X = Y, and missing y
({ y }: O4); // Error: missing x
({ x }: O4); // OK
({ x, y }: O4); // OK
({ x: y }: O4); // Error: Y ~> X

type O5 = $Rest<{ x: X, y: Y }, {| y: Y |}>;
declare var o5: O5;
(o5: {| x?: X |}); // Error: inexact ~> exact
(o5: {}); // OK
(o5: { x: X }); // Error: x is optional
(o5: { x?: X }); // OK
(o5: { x: X, y?: Y }); // Error: x is optional and y is not in O5
(o5: { x?: X, y?: Y }); // Error: y is not in O5
(o5: { x: Y }); // Error: x is optional and X = Y
({}: O5); // OK
({ x }: O5); // OK
({ x, y }: O5); // OK
({ x: y }: O5); // Error: Y ~> X

type O6 = $Rest<{ x: X, y: Y }, { y: Y }>;
declare var o6: O6;
(o6: {| x?: X, y?: Y |}); // Error: inexact ~> exact
(o6: {}); // OK
(o6: { x: X }); // Error: x is optional
(o6: { x?: X }); // OK
(o6: { x: X, y?: Y }); // Error: x is optional
(o6: { x?: X, y?: Y }); // OK
(o6: { x: Y }); // Error: X = Y, x is optional
({}: O6); // OK
({ x }: O6); // OK
({ x, y }: O6); // OK
({ x: y }: O6); // Error: Y ~> X

type O7 = $Rest<{ x: X, y: Y }, {| y?: Y |}>;
declare var o7: O7;
(o7: {| x?: X, y?: Y |}); // Error: inexact ~> exact
(o7: {}); // OK
(o7: { x: X }); // Error: x is optional
(o7: { x?: X }); // OK
(o7: { x: X, y?: Y }); // Error: x is optional
(o7: { x?: X, y?: Y }); // OK
(o7: { x: Y }); // Error: X = Y and x is optional
({}: O7); // OK
({ x }: O7); // OK
({ x, y }: O7); // OK
({ x: y }: O7); // Error: Y ~> X

type O8 = $Rest<{ x: X, y: Y }, {| y: X |}>; // Error: Y ~> X
declare var o8: O8;
(o8: { x?: X }); // OK

type O9 = $Rest<{| x: X, y: Y |}, { y: X }>; // Error: Y ~> X
declare var o9: O9;
(o9: {| x?: X, y?: Y |}); // OK

type O10 = $Rest<{| x: X, y: Y |}, {| y?: X |}>; // Error: Y ~> X
declare var o10: O10;
(o10: {| x: X, y?: Y |}); // OK

type O11 = $Rest<{| x: X, y?: Y |}, {| y: Y |}>; // Error: void ~> Y
declare var o11: O11;
(o11: {| x: X |}); // OK

type O12 = $Rest<{| x: X |}, {| y: Y |}>; // Error: void ~> Y
declare var o12: O12;
(o12: {| x: X |}); // OK

type O13 = $Rest<{| x: X, y?: Y |}, {| y: Y | void |}>;
declare var o13: O13;
(o13: {| x: X |}); // OK

type O14 = $Rest<{| x: X |}, {| y: Y | void |}>;
declare var o14: O14;
(o14: {| x: X |}); // OK

type O15 = $Rest<{| x: X, y: Y |}, {| y?: Y |}>;
declare var o15: O15;
(o15: {| x: X, y?: Y |}); // OK

type O16 = $Rest<{| x: X, y: Y |}, { y: Y }>;
declare var o16: O16;
(o16: {| x?: X, y?: Y |}); // OK

type O17 = $Rest<{| x: X, y?: Y |}, {| y?: Y |}>;
declare var o17: O17;
(o17: {| x: X, y?: Y |}); // OK

================================================================================
`;

exports[`type_dict.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

declare opaque type X;
declare opaque type Y;
declare var x: X;
declare var y: Y;

type O1 = $Rest<{|y: Y|}, {|[string]: Y|}>;
declare var o1: O1;
(o1: {||}); // Error: missing y
(o1: {|y: Y|}); // Error: y is optional
(o1: {|y?: Y|}); // OK
(o1: {|y?: X|}); // Error: Y = X
({}: O1); // OK
({y}: O1); // OK
({y: x}: O1); // Error: X ~> Y

type O2 = $Rest<{|y: Y|}, {|[string]: X|}>; // Error: Y ~> X
declare var o2: O2;
(o2: {|y?: Y|}); // OK

type O3 = $Rest<{|y: Y|}, {[string]: Y}>;
declare var o3: O3;
(o3: {||}); // Error: missing y
(o3: {|y: Y|}); // Error: y is optional
(o3: {|y?: Y|}); // OK
(o3: {|y?: X|}); // Error: Y = X
({}: O3); // OK
({y}: O3); // OK
({y: x}: O3); // Error: X ~> Y

type O4 = $Rest<{y: Y}, {|[string]: Y|}>;
declare var o4: O4;
(o4: {|y?: Y|}); // Error: inexact ~> exact
(o4: {}); // OK
(o4: {y: Y}); // Error: y is optional
(o4: {y?: Y}); // OK
(o4: {y?: X}); // Error: Y = X
({}: O4); // OK
({y}: O4); // OK
({y, x}: O4); // OK
({y: x}: O4); // Error: X ~> Y

type O5 = $Rest<{y: Y}, {[string]: Y}>;
declare var o5: O5;
(o5: {|y?: Y|}); // Error: inexact ~> exact
(o5: {}); // OK
(o5: {y: Y}); // Error: y is optional
(o5: {y?: Y}); // OK
(o5: {y?: X}); // Error: Y = X
({}: O5); // OK
({y}: O5); // OK
({y, x}: O5); // OK
({y: x}: O5); // Error: X ~> Y

type O6 = $Rest<{y: Y}, {|[string]: X|}>; // Error: Y ~> X
declare var o6: O6;
(o6: {y?: Y}); // OK

type O7 = $Rest<{|y: Y|}, {[string]: X}>; // Error: Y ~> X
declare var o7: O7;
(o7: {|y?: Y|}); // OK

type O8 = $Rest<{|y?: Y|}, {|[string]: Y|}>;
declare var o8: O8;
(o8: {|y?: Y|}); // OK

type O9 = $Rest<{|y?: Y|}, {|[string]: Y | void|}>;
declare var o9: O9;
(o9: {|y?: Y|}); // OK

type O10 = $Rest<{|x: X, y: Y|}, {|[string]: X | Y|}>;
declare var o10: O10;
(o10: {|x?: X, y?: Y|}); // OK

type O11 = $Rest<{|x: X, y: Y|}, {[string]: X | Y}>;
declare var o11: O11;
(o11: {|x?: X, y?: Y|}); // OK

type O12 = $Rest<{x: X, y: Y}, {|[string]: X | Y|}>;
declare var o12: O12;
(o12: {x?: X, y?: Y}); // OK

type O13 = $Rest<{|[string]: X|}, {|[string]: Y|}>; // Error: X ~> Y
declare var o13: O13;
(o13: {|[string]: X | void|}); // OK

type O14 = $Rest<{|[string]: X|}, {|[string]: X|}>;
declare var o14: O14;
(o14: {|[string]: X | void|}); // OK

type O15 = $Rest<{|x: X, [string]: Y|}, {|[string]: X | Y|}>;
declare var o15: O15;
(o15: {|x?: X, [string]: Y | void|}); // OK

type O16 = $Rest<{|[string]: X|}, {|y: Y|}>; // Error: X ~> Y and void ~> Y
declare var o16: O16;
(o16: {|[string]: X|}); // OK

type O17 = $Rest<{|x: X, [string]: Y|}, {|x: X, [string]: Y|}>;
declare var o17: O17;
(o17: {|[string]: Y | void|}); // OK

=====================================output=====================================
// @flow

declare opaque type X;
declare opaque type Y;
declare var x: X;
declare var y: Y;

type O1 = $Rest<{| y: Y |}, {| [string]: Y |}>;
declare var o1: O1;
(o1: {||}); // Error: missing y
(o1: {| y: Y |}); // Error: y is optional
(o1: {| y?: Y |}); // OK
(o1: {| y?: X |}); // Error: Y = X
({}: O1); // OK
({ y }: O1); // OK
({ y: x }: O1); // Error: X ~> Y

type O2 = $Rest<{| y: Y |}, {| [string]: X |}>; // Error: Y ~> X
declare var o2: O2;
(o2: {| y?: Y |}); // OK

type O3 = $Rest<{| y: Y |}, { [string]: Y }>;
declare var o3: O3;
(o3: {||}); // Error: missing y
(o3: {| y: Y |}); // Error: y is optional
(o3: {| y?: Y |}); // OK
(o3: {| y?: X |}); // Error: Y = X
({}: O3); // OK
({ y }: O3); // OK
({ y: x }: O3); // Error: X ~> Y

type O4 = $Rest<{ y: Y }, {| [string]: Y |}>;
declare var o4: O4;
(o4: {| y?: Y |}); // Error: inexact ~> exact
(o4: {}); // OK
(o4: { y: Y }); // Error: y is optional
(o4: { y?: Y }); // OK
(o4: { y?: X }); // Error: Y = X
({}: O4); // OK
({ y }: O4); // OK
({ y, x }: O4); // OK
({ y: x }: O4); // Error: X ~> Y

type O5 = $Rest<{ y: Y }, { [string]: Y }>;
declare var o5: O5;
(o5: {| y?: Y |}); // Error: inexact ~> exact
(o5: {}); // OK
(o5: { y: Y }); // Error: y is optional
(o5: { y?: Y }); // OK
(o5: { y?: X }); // Error: Y = X
({}: O5); // OK
({ y }: O5); // OK
({ y, x }: O5); // OK
({ y: x }: O5); // Error: X ~> Y

type O6 = $Rest<{ y: Y }, {| [string]: X |}>; // Error: Y ~> X
declare var o6: O6;
(o6: { y?: Y }); // OK

type O7 = $Rest<{| y: Y |}, { [string]: X }>; // Error: Y ~> X
declare var o7: O7;
(o7: {| y?: Y |}); // OK

type O8 = $Rest<{| y?: Y |}, {| [string]: Y |}>;
declare var o8: O8;
(o8: {| y?: Y |}); // OK

type O9 = $Rest<{| y?: Y |}, {| [string]: Y | void |}>;
declare var o9: O9;
(o9: {| y?: Y |}); // OK

type O10 = $Rest<{| x: X, y: Y |}, {| [string]: X | Y |}>;
declare var o10: O10;
(o10: {| x?: X, y?: Y |}); // OK

type O11 = $Rest<{| x: X, y: Y |}, { [string]: X | Y }>;
declare var o11: O11;
(o11: {| x?: X, y?: Y |}); // OK

type O12 = $Rest<{ x: X, y: Y }, {| [string]: X | Y |}>;
declare var o12: O12;
(o12: { x?: X, y?: Y }); // OK

type O13 = $Rest<{| [string]: X |}, {| [string]: Y |}>; // Error: X ~> Y
declare var o13: O13;
(o13: {| [string]: X | void |}); // OK

type O14 = $Rest<{| [string]: X |}, {| [string]: X |}>;
declare var o14: O14;
(o14: {| [string]: X | void |}); // OK

type O15 = $Rest<{| x: X, [string]: Y |}, {| [string]: X | Y |}>;
declare var o15: O15;
(o15: {| x?: X, [string]: Y | void |}); // OK

type O16 = $Rest<{| [string]: X |}, {| y: Y |}>; // Error: X ~> Y and void ~> Y
declare var o16: O16;
(o16: {| [string]: X |}); // OK

type O17 = $Rest<{| x: X, [string]: Y |}, {| x: X, [string]: Y |}>;
declare var o17: O17;
(o17: {| [string]: Y | void |}); // OK

================================================================================
`;

exports[`type_generic.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
function remove<A, B>(a: A): [$Rest<A, {p: B}>, B] {
  const {p, ...o} = a;
  return [o, p];
}

const [o, p] = remove({x: 'foo', p: 42});
(o: {|x: string|});
(p: number);

=====================================output=====================================
function remove<A, B>(a: A): [$Rest<A, { p: B }>, B] {
  const { p, ...o } = a;
  return [o, p];
}

const [o, p] = remove({ x: "foo", p: 42 });
(o: {| x: string |});
(p: number);

================================================================================
`;

exports[`type_union.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

declare opaque type X;
declare opaque type Y;
declare var x: X;
declare var y: Y;
declare var o: {||};

// Some of the test types in this module are polymorphic in X and Y, for
// example O1<X, Y> so that we re-evaluate the $Rest type whenever we use it.

type O1<X, Y> = $Rest<{|x: X|} | {|y: Y|}, {|x: X | void|}>;
(o: O1<X, Y>); // OK
({x}: O1<X, Y>); // Error: x is not allowed
({y}: O1<X, Y>); // OK
({x, y}: O1<X, Y>); // Error: x is not allowed

type O2<X, Y> = $Rest<{|x: X|} | {|y: Y|}, {|y: Y | void|}>;
(o: O2<X, Y>); // OK
({x}: O2<X, Y>); // OK
({y}: O2<X, Y>); // Error: y is not allowed
({x, y}: O2<X, Y>); // Error: y is not allowed

type O3 = $Rest<{|x: X|} | {|y: Y|}, {|x: X, y: Y|}>; // Error: void ~> X and void ~> Y
(o: O3); // OK

type O4 = $Rest<{|x: X|} | {|y: Y|}, {|x: X | void, y: Y | void|}>;
(o: O4); // OK
({x}: O4); // Error: x is not allowed
({y}: O4); // Error: y is not allowed
({x, y}: O4); // Error: x and y are not allowed

type O5 = $Rest<{|x: X, y: Y|}, {|x: X|} | {|y: Y|}>;
(o: O5); // Error: missing x and missing y
({x}: O5); // OK
({y}: O5); // OK
({x, y}: O5); // Error: x and y are not allowed together

type O6 = $Rest<{|x: X|}, {|x: X|} | {|y: Y|}>; // Error: void ~> Y
(o: O6); // OK

type O7 = $Rest<{|y: Y|}, {|x: X | void|} | {|y: Y|}>;
(o: O7); // OK
({x}: O7); // Error: x is not allowed
({y}: O7); // OK
({x, y}: O7); // Error: x is not allowed

type O8 = $Rest<{|x: X|} | {|y: Y|}, {|x: X|} | {|y: Y|}>; // Error: void ~> X and void ~> Y
(o: O8); // OK

type O9 = $Rest<{|x: X|} | {|y: Y|}, {|x: X | void|} | {|y: Y | void|}>;
(o: O9); // OK
({x}: O9); // OK
({y}: O9); // OK
({x, y}: O9); // Error: x and y are not allowed together

=====================================output=====================================
// @flow

declare opaque type X;
declare opaque type Y;
declare var x: X;
declare var y: Y;
declare var o: {||};

// Some of the test types in this module are polymorphic in X and Y, for
// example O1<X, Y> so that we re-evaluate the $Rest type whenever we use it.

type O1<X, Y> = $Rest<{| x: X |} | {| y: Y |}, {| x: X | void |}>;
(o: O1<X, Y>); // OK
({ x }: O1<X, Y>); // Error: x is not allowed
({ y }: O1<X, Y>); // OK
({ x, y }: O1<X, Y>); // Error: x is not allowed

type O2<X, Y> = $Rest<{| x: X |} | {| y: Y |}, {| y: Y | void |}>;
(o: O2<X, Y>); // OK
({ x }: O2<X, Y>); // OK
({ y }: O2<X, Y>); // Error: y is not allowed
({ x, y }: O2<X, Y>); // Error: y is not allowed

type O3 = $Rest<{| x: X |} | {| y: Y |}, {| x: X, y: Y |}>; // Error: void ~> X and void ~> Y
(o: O3); // OK

type O4 = $Rest<{| x: X |} | {| y: Y |}, {| x: X | void, y: Y | void |}>;
(o: O4); // OK
({ x }: O4); // Error: x is not allowed
({ y }: O4); // Error: y is not allowed
({ x, y }: O4); // Error: x and y are not allowed

type O5 = $Rest<{| x: X, y: Y |}, {| x: X |} | {| y: Y |}>;
(o: O5); // Error: missing x and missing y
({ x }: O5); // OK
({ y }: O5); // OK
({ x, y }: O5); // Error: x and y are not allowed together

type O6 = $Rest<{| x: X |}, {| x: X |} | {| y: Y |}>; // Error: void ~> Y
(o: O6); // OK

type O7 = $Rest<{| y: Y |}, {| x: X | void |} | {| y: Y |}>;
(o: O7); // OK
({ x }: O7); // Error: x is not allowed
({ y }: O7); // OK
({ x, y }: O7); // Error: x is not allowed

type O8 = $Rest<{| x: X |} | {| y: Y |}, {| x: X |} | {| y: Y |}>; // Error: void ~> X and void ~> Y
(o: O8); // OK

type O9 = $Rest<{| x: X |} | {| y: Y |}, {| x: X | void |} | {| y: Y | void |}>;
(o: O9); // OK
({ x }: O9); // OK
({ y }: O9); // OK
({ x, y }: O9); // Error: x and y are not allowed together

================================================================================
`;
