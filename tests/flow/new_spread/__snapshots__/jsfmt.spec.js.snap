// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`no_interfaces.js format 1`] = `
====================================options=====================================
parsers: ["flow", "babel"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
//@flow

interface A {}
interface B {}

function spread<A: {}, B: {}>(
    x: A,
    y: B,
): {...A, ...B} {
  return (null: any);
}

declare var a: A;
declare var b: B;

spread<A, B>(a, b); // Error, can't spread interface

type X = {...A, ...B}; // Error, can't spread interface

declare var x: X;
(x: any);

type Y = {...A, foo: number}; // Error, can't spread interface
declare var y: Y;
(y: any);

type Z = {foo: number, ...A}; // Error, can't spread interface
declare var z: Z;
(z: any);

// Instances and classes can be spread:
class F {}
type G = {...F, ...Class<F>}; // Ok
declare var g: G;
(g: any);

=====================================output=====================================
//@flow

interface A {}
interface B {}

function spread<A: {}, B: {}>(x: A, y: B): { ...A, ...B } {
  return (null: any);
}

declare var a: A;
declare var b: B;

spread<A, B>(a, b); // Error, can't spread interface

type X = { ...A, ...B }; // Error, can't spread interface

declare var x: X;
(x: any);

type Y = { ...A, foo: number }; // Error, can't spread interface
declare var y: Y;
(y: any);

type Z = { foo: number, ...A }; // Error, can't spread interface
declare var z: Z;
(z: any);

// Instances and classes can be spread:
class F {}
type G = { ...F, ...Class<F> }; // Ok
declare var g: G;
(g: any);

================================================================================
`;

exports[`type.js format 1`] = `
====================================options=====================================
parsers: ["flow", "babel"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
declare class T {}
declare var x: T;

declare class U {}
declare var y: U;

declare var nil: {||};

// inexact: \`p\` may be non-own
type O1 = {...{p:T}};
declare var o1: O1;
(o1: {p?:T}); // ok
(o1: {p:T}); // error: o1.p is optional
({}: O1); // ok
({p:x}: O1); // ok
({p:y}: O1); // error: y ~> T
({p:x,q:y}: O1); // ok

// inexact: optional \`p\`, if own, must be \`T\`
type O2 = {...{p?:T}};
declare var o2: O2;
(o2: {p?:T}); // ok
(o2: {p:T}); // error: o2.p is optional
({}: O2); // ok
({p:x}: O2); // ok
({p:y}: O2); // error: y ~> T
({p:x,q:y}: O2); // ok

// can't make exact from inexact (TODO: force EvalT eagerly)
type O3 = {|...{p:T}|}; ({p:x}: O3); // error: spread result is not exact

// exact
type O4 = {...{|p:T|}};
declare var o4: O4;
(o4: {p:T}); // ok
(o4: {|p:T|}); // error: not exact
(({}:{}): O4); // error: property \`p\` not found
({p:x}: O4); // ok
({p:y}: O4); // error: y ~> T
({p:x,q:y}: O4); // ok

// can make exact from exact
type O5 = {|...{|p:T|}|};
declare var o5: O5;
(o5: {p:T}); // ok
(o5: {|p:T|}); // ok
(nil: O5); // error: property \`p\` not found
({p:x}: O5); // ok
({p:y}: O5); // error: y ~> T
({p:x,q:y}: O5); // error: additional property \`q\` found

// inexact p + exact p
type O6 = {...{p:T},...{|p:U|}};
declare var o6: O6;
(o6: {p:U}); // ok
(({}:{}): O6); // error: property \`p\` not found
({p:x}: O6); // error: x ~> U
({p:y}: O6); // ok
({p:y,q:x}: O6); // ok

// inexact p + exact p ~> exact (TODO: force EvalT eagerly)
type O7 = {|...{p:T},...{|p:U|}|}; ({p:y}: O7);// error: spread result is not exact

// exact p + inexact p
type O8 = {...{|p:T|},...{p:U}};
declare var o8: O8;
(o8: {p:U}); // ok
(o8.p: T); // error: U ~> T


// inexact p + exact q
type O9 = {...{p:T},...{|q:U|}};
declare var o9: O9;
(o9: {p?:T,q:U});
(o9.p: T); // error: o9.p is optional
(o9.q: U); // ok

// exact p + inexact q
type O10 = {...{|p:T|},...{q:U}}; // Error, p may exist in second object
declare var o10: O10;
(o10: {p:any, q: any});

// inexact p + inexact q
type O11 = {...{p:T},...{q:U}}; // Error, p may exist in second object
declare var o11: O11;
(o11: {p:any, q: any}); // Error

// exact + exact
type O12 = {...{|p:T|},...{|q:U|}};
declare var o12: O12;
(o12: {p:T,q:U}); // ok

// inline properties are exact
type O13 = {...{p:T},p:U};
declare var o13: O13;
(o13: {p:U});

// exact types spread in an inexact type is inexact when spread again
type O14 = {...{...{|p:T|}}};
declare var o14: O14;
(o14: {p:T}); // error: \`p\` is optional
(o14: {p?:T}); // ok
(o14: {}); // ok
({p:x}: O14); // ok
({p:y}: O14); // error: U ~> T
({}: O14); // ok

=====================================output=====================================
declare class T {}
declare var x: T;

declare class U {}
declare var y: U;

declare var nil: {||};

// inexact: \`p\` may be non-own
type O1 = { ...{ p: T } };
declare var o1: O1;
(o1: { p?: T }); // ok
(o1: { p: T }); // error: o1.p is optional
({}: O1); // ok
({ p: x }: O1); // ok
({ p: y }: O1); // error: y ~> T
({ p: x, q: y }: O1); // ok

// inexact: optional \`p\`, if own, must be \`T\`
type O2 = { ...{ p?: T } };
declare var o2: O2;
(o2: { p?: T }); // ok
(o2: { p: T }); // error: o2.p is optional
({}: O2); // ok
({ p: x }: O2); // ok
({ p: y }: O2); // error: y ~> T
({ p: x, q: y }: O2); // ok

// can't make exact from inexact (TODO: force EvalT eagerly)
type O3 = {| ...{ p: T } |};
({ p: x }: O3); // error: spread result is not exact

// exact
type O4 = { ...{| p: T |} };
declare var o4: O4;
(o4: { p: T }); // ok
(o4: {| p: T |}); // error: not exact
(({}: {}): O4); // error: property \`p\` not found
({ p: x }: O4); // ok
({ p: y }: O4); // error: y ~> T
({ p: x, q: y }: O4); // ok

// can make exact from exact
type O5 = {| ...{| p: T |} |};
declare var o5: O5;
(o5: { p: T }); // ok
(o5: {| p: T |}); // ok
(nil: O5); // error: property \`p\` not found
({ p: x }: O5); // ok
({ p: y }: O5); // error: y ~> T
({ p: x, q: y }: O5); // error: additional property \`q\` found

// inexact p + exact p
type O6 = { ...{ p: T }, ...{| p: U |} };
declare var o6: O6;
(o6: { p: U }); // ok
(({}: {}): O6); // error: property \`p\` not found
({ p: x }: O6); // error: x ~> U
({ p: y }: O6); // ok
({ p: y, q: x }: O6); // ok

// inexact p + exact p ~> exact (TODO: force EvalT eagerly)
type O7 = {| ...{ p: T }, ...{| p: U |} |};
({ p: y }: O7); // error: spread result is not exact

// exact p + inexact p
type O8 = { ...{| p: T |}, ...{ p: U } };
declare var o8: O8;
(o8: { p: U }); // ok
(o8.p: T); // error: U ~> T

// inexact p + exact q
type O9 = { ...{ p: T }, ...{| q: U |} };
declare var o9: O9;
(o9: { p?: T, q: U });
(o9.p: T); // error: o9.p is optional
(o9.q: U); // ok

// exact p + inexact q
type O10 = { ...{| p: T |}, ...{ q: U } }; // Error, p may exist in second object
declare var o10: O10;
(o10: { p: any, q: any });

// inexact p + inexact q
type O11 = { ...{ p: T }, ...{ q: U } }; // Error, p may exist in second object
declare var o11: O11;
(o11: { p: any, q: any }); // Error

// exact + exact
type O12 = { ...{| p: T |}, ...{| q: U |} };
declare var o12: O12;
(o12: { p: T, q: U }); // ok

// inline properties are exact
type O13 = { ...{ p: T }, p: U };
declare var o13: O13;
(o13: { p: U });

// exact types spread in an inexact type is inexact when spread again
type O14 = { ...{ ...{| p: T |} } };
declare var o14: O14;
(o14: { p: T }); // error: \`p\` is optional
(o14: { p?: T }); // ok
(o14: {}); // ok
({ p: x }: O14); // ok
({ p: y }: O14); // error: U ~> T
({}: O14); // ok

================================================================================
`;

exports[`type_any.js format 1`] = `
====================================options=====================================
parsers: ["flow", "babel"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
type O1 = {...any};
var o1: O1 = (0: mixed); // ok
(o1: empty); // ok

type O2 = {...Object};
var o2: O2 = (0: mixed); // ok
(o2: empty); // ok

declare var Base: any;
declare class Derived extends Base {}
type O3 = {...Derived};
var o3: O3 = (0: mixed); // ok
(o3: empty) // ok

=====================================output=====================================
type O1 = { ...any };
var o1: O1 = (0: mixed); // ok
(o1: empty); // ok

type O2 = { ...Object };
var o2: O2 = (0: mixed); // ok
(o2: empty); // ok

declare var Base: any;
declare class Derived extends Base {}
type O3 = { ...Derived };
var o3: O3 = (0: mixed); // ok
(o3: empty); // ok

================================================================================
`;

exports[`type_contra.js format 1`] = `
====================================options=====================================
parsers: ["flow", "babel"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
declare class T {};

type O1 = {...{-p:T}};
declare var o1: O1;
(o1: {p?:mixed}); // ok
(o1: {p?:T}); // error: unknown ~> T
(o1.p: T); // errors: undefined ~> T, unknown ~> T

type O2 = {...{-[string]:T}};
declare var o2: O2;
(o2: {[string]:mixed}); // ok
(o2: {[string]:T}); // error: unknown ~> T
(o2.p: T); // errors: unknown ~> T

type O3 = {...{||}, -p: T};
declare var o3: O3;
(o3: {p:mixed}); // ok
(o3: {p:T}); // error: unknown ~> T
(o3.p: T); // errors: unknown ~> T

=====================================output=====================================
declare class T {}

type O1 = { ...{ -p: T } };
declare var o1: O1;
(o1: { p?: mixed }); // ok
(o1: { p?: T }); // error: unknown ~> T
(o1.p: T); // errors: undefined ~> T, unknown ~> T

type O2 = { ...{ -[string]: T } };
declare var o2: O2;
(o2: { [string]: mixed }); // ok
(o2: { [string]: T }); // error: unknown ~> T
(o2.p: T); // errors: unknown ~> T

type O3 = { ...{||}, -p: T };
declare var o3: O3;
(o3: { p: mixed }); // ok
(o3: { p: T }); // error: unknown ~> T
(o3.p: T); // errors: unknown ~> T

================================================================================
`;

exports[`type_dict.js format 1`] = `
====================================options=====================================
parsers: ["flow", "babel"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
declare class T {}
declare class U {}

declare var o1: {...{[string]:T},...{p:U}}; // Error, can't spread because inexact may clash with T
(o1: {p?:T|U,[string]:T});


=====================================output=====================================
declare class T {}
declare class U {}

declare var o1: { ...{ [string]: T }, ...{ p: U } }; // Error, can't spread because inexact may clash with T
(o1: { p?: T | U, [string]: T });

================================================================================
`;

exports[`type_empty.js format 1`] = `
====================================options=====================================
parsers: ["flow", "babel"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

type O = {...empty};
declare var o: O;
(42: O); // Error: number ~> empty
(o: empty); // OK: empty ~> empty

function fn1<T>(x: {...T}) {
  (x: number); // Error: mixed ~> number,
               // but only one error. empty ~> number is ok.
}

function fn2<T>(fn: ({...T}) => void) {
  fn({}); // Error: object ~> empty
}

function fn3<T>(x: T, fn: ({...T, foo: number}) => void) {
  fn({...x, foo: 42}); // OK
}

=====================================output=====================================
// @flow

type O = { ...empty };
declare var o: O;
(42: O); // Error: number ~> empty
(o: empty); // OK: empty ~> empty

function fn1<T>(x: { ...T }) {
  (x: number); // Error: mixed ~> number,
  // but only one error. empty ~> number is ok.
}

function fn2<T>(fn: ({ ...T }) => void) {
  fn({}); // Error: object ~> empty
}

function fn3<T>(x: T, fn: ({ ...T, foo: number }) => void) {
  fn({ ...x, foo: 42 }); // OK
}

================================================================================
`;

exports[`type_generic.js format 1`] = `
====================================options=====================================
parsers: ["flow", "babel"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
declare function spread<A,B>(a: A, b: B): {|...A, ...B|};
(spread({p:0},{q:0}): {|+p:number,+q:number|}); // ok
(spread({p:0},{q:0}): {|+p:empty,+q:empty|}); // number ~> empty (x2)

=====================================output=====================================
declare function spread<A, B>(a: A, b: B): {| ...A, ...B |};
(spread({ p: 0 }, { q: 0 }): {| +p: number, +q: number |}); // ok
(spread({ p: 0 }, { q: 0 }): {| +p: empty, +q: empty |}); // number ~> empty (x2)

================================================================================
`;

exports[`type_instance.js format 1`] = `
====================================options=====================================
parsers: ["flow", "babel"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
class A {+p: string|number}
class B extends A {p: number}

type O1 = {...B};
declare var o1: O1;
(o1: {p?:number}); // Error

declare class C {[string]:number}
type O2 = {...C};
declare var o2: O2;
(o2: {[string]:number}); // ok

=====================================output=====================================
class A {
  +p: string | number;
}
class B extends A {
  p: number;
}

type O1 = { ...B };
declare var o1: O1;
(o1: { p?: number }); // Error

declare class C {
  [string]: number;
}
type O2 = { ...C };
declare var o2: O2;
(o2: { [string]: number }); // ok

================================================================================
`;

exports[`type_intersection.js format 1`] = `
====================================options=====================================
parsers: ["flow", "babel"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
declare class T {}
declare class U {}

declare class A {}
declare class B extends A {}

type O1 = {...{p:T}&{q:U}};
declare var o1: O1;
(o1: {p?:T,q?:U}); // ok

type O2 = {...{p:A}&{p:B}};
declare var o2: O2;
(o2: {p?:B}); // ok
({p: new B}: O2); // ok
({p: new A}: O2); // error: A ~> B

type O3 = {...{p:A}&{[string]:B}};
declare var o3: O3;
(o3: {p:B,[string]:B});// ok: A&B = B
(o3.q: B); // ok

type O4 = {...{[string]:A}&{p:B}};
declare var o4: O4;
(o4: {p:B,[string]:A}); // ok: A&B = B

type O5 = {...{[string]:A}&{[string]:B}};
declare var o5: O5;
(o5: {[string]:B}); // ok: A&B = B

=====================================output=====================================
declare class T {}
declare class U {}

declare class A {}
declare class B extends A {}

type O1 = { ...{ p: T } & { q: U } };
declare var o1: O1;
(o1: { p?: T, q?: U }); // ok

type O2 = { ...{ p: A } & { p: B } };
declare var o2: O2;
(o2: { p?: B }); // ok
({ p: new B() }: O2); // ok
({ p: new A() }: O2); // error: A ~> B

type O3 = { ...{ p: A } & { [string]: B } };
declare var o3: O3;
(o3: { p: B, [string]: B }); // ok: A&B = B
(o3.q: B); // ok

type O4 = { ...{ [string]: A } & { p: B } };
declare var o4: O4;
(o4: { p: B, [string]: A }); // ok: A&B = B

type O5 = { ...{ [string]: A } & { [string]: B } };
declare var o5: O5;
(o5: { [string]: B }); // ok: A&B = B

================================================================================
`;

exports[`type_intersection_optional.js format 1`] = `
====================================options=====================================
parsers: ["flow", "babel"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
declare class T {}
declare class U {}

declare var o1: {...{p:T}&{p:U}};
(o1: {p?:T&U}); // ok

declare var o2: {...{p?:T}&{p:U}};
(o2: {p?:T&U}); // ok

declare var o3: {...{p:T}&{p?:U}};
(o3: {p?:T&U}); // ok

declare var o4: {...{p?:T}&{p?:U}};
(o4: {p?:T&U}); // ok

declare var o5: {...{|p:T|}&{p:U}};
(o5: {p:T&U}); // ok

declare var o6: {...{|p?:T|}&{p:U}};
(o6: {p:T&U}); // ok

declare var o7: {...{|p:T|}&{p?:U}};
(o7: {p:T&U}); // ok

declare var o8: {...{|p?:T|}&{p?:U}};
(o8: {p?:T&U}); // ok

declare var o9: {...{p:T}&{|p:U|}};
(o9: {p:T&U}); // ok

declare var o10: {...{p?:T}&{|p:U|}};
(o10: {p:T&U}); // ok

declare var o11: {...{p:T}&{|p?:U|}};
(o11: {p:T&U}); // ok

declare var o12: {...{p?:T}&{|p?:U|}};
(o12: {p?:T&U}); // ok

declare var o13: {|...{|p:T|}&{|p:U|}|};
(o13: {|p:T&U|}); // ok

declare var o14: {|...{|p?:T|}&{|p:U|}|};
(o14: {|p:T&U|}); // ok

declare var o15: {|...{|p:T|}&{|p?:U|}|};
(o15: {|p:T&U|}); // ok

declare var o16: {|...{|p?:T|}&{|p?:U|}|};
(o16: {|p?:T&U|}); // ok

declare var o17: {...{p:T}&{q:U}};
(o17: {p?:T,q?:U}); // ok

declare var o18: {...{p?:T}&{q:U}};
(o18: {p?:T,q?:U}); // ok

declare var o19: {...{p:T}&{q?:U}};
(o19: {p?:T,q?:U}); // ok

declare var o20: {...{p?:T}&{q?:U}};
(o20: {p?:T,q?:U}); // ok

declare var o21: {...{|p:T|}&{q:U}};
(o21: {p:T,q?:U}); // ok

=====================================output=====================================
declare class T {}
declare class U {}

declare var o1: { ...{ p: T } & { p: U } };
(o1: { p?: T & U }); // ok

declare var o2: { ...{ p?: T } & { p: U } };
(o2: { p?: T & U }); // ok

declare var o3: { ...{ p: T } & { p?: U } };
(o3: { p?: T & U }); // ok

declare var o4: { ...{ p?: T } & { p?: U } };
(o4: { p?: T & U }); // ok

declare var o5: { ...{| p: T |} & { p: U } };
(o5: { p: T & U }); // ok

declare var o6: { ...{| p?: T |} & { p: U } };
(o6: { p: T & U }); // ok

declare var o7: { ...{| p: T |} & { p?: U } };
(o7: { p: T & U }); // ok

declare var o8: { ...{| p?: T |} & { p?: U } };
(o8: { p?: T & U }); // ok

declare var o9: { ...{ p: T } & {| p: U |} };
(o9: { p: T & U }); // ok

declare var o10: { ...{ p?: T } & {| p: U |} };
(o10: { p: T & U }); // ok

declare var o11: { ...{ p: T } & {| p?: U |} };
(o11: { p: T & U }); // ok

declare var o12: { ...{ p?: T } & {| p?: U |} };
(o12: { p?: T & U }); // ok

declare var o13: {| ...{| p: T |} & {| p: U |} |};
(o13: {| p: T & U |}); // ok

declare var o14: {| ...{| p?: T |} & {| p: U |} |};
(o14: {| p: T & U |}); // ok

declare var o15: {| ...{| p: T |} & {| p?: U |} |};
(o15: {| p: T & U |}); // ok

declare var o16: {| ...{| p?: T |} & {| p?: U |} |};
(o16: {| p?: T & U |}); // ok

declare var o17: { ...{ p: T } & { q: U } };
(o17: { p?: T, q?: U }); // ok

declare var o18: { ...{ p?: T } & { q: U } };
(o18: { p?: T, q?: U }); // ok

declare var o19: { ...{ p: T } & { q?: U } };
(o19: { p?: T, q?: U }); // ok

declare var o20: { ...{ p?: T } & { q?: U } };
(o20: { p?: T, q?: U }); // ok

declare var o21: { ...{| p: T |} & { q: U } };
(o21: { p: T, q?: U }); // ok

================================================================================
`;

exports[`type_mixed.js format 1`] = `
====================================options=====================================
parsers: ["flow", "babel"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

type O1 = {...mixed};
declare var o1: O1;
(o1.someProp: empty); // Error someProp does not exist

type O2 = {|...mixed|};
declare var o2: O2;
(o2.someProp: empty); // Error someProp does not exist

type O3 = {...mixed, ...{|a: number, b?: number|}};
declare var o3: O3;
(o3.a: empty); // Error: number ~> empty
(o3.b: empty); // Error: mixed ~> empty, number ~> empty, and undefined ~> empty
(o3.c: empty); // Error c does not exist

function fn<O>(obj: {...O}) {
  (obj.someProp: empty); // Error someProp does not exist
}

=====================================output=====================================
// @flow

type O1 = { ...mixed };
declare var o1: O1;
(o1.someProp: empty); // Error someProp does not exist

type O2 = {| ...mixed |};
declare var o2: O2;
(o2.someProp: empty); // Error someProp does not exist

type O3 = { ...mixed, ...{| a: number, b?: number |} };
declare var o3: O3;
(o3.a: empty); // Error: number ~> empty
(o3.b: empty); // Error: mixed ~> empty, number ~> empty, and undefined ~> empty
(o3.c: empty); // Error c does not exist

function fn<O>(obj: { ...O }) {
  (obj.someProp: empty); // Error someProp does not exist
}

================================================================================
`;

exports[`type_optional.js format 1`] = `
====================================options=====================================
parsers: ["flow", "babel"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
declare class T {}
declare class U {}

declare var a: {...{ p :T },...{ p :U }}; (a: { p:U });
declare var b: {...{ p?:T },...{ p :U }}; (b: { p:U });
declare var c: {...{ p :T },...{ p?:U }}; (c: { p:T|U });
declare var d: {...{ p?:T },...{ p?:U }}; (d: { p?:T|U });

declare var e: {...{|p :T|},...{ p :U }}; (e: { p :U });
declare var f: {...{|p?:T|},...{ p :U }}; (f: { p:U });
declare var g: {...{|p :T|},...{ p?:U }}; (g: { p :T|U });
declare var h: {...{|p?:T|},...{ p?:U }}; (h: { p?:T|U });

declare var i: {...{ p :T },...{|p :U|}}; (i: { p :  U });
declare var j: {...{ p?:T },...{|p :U|}}; (j: { p :  U });
declare var k: {...{ p :T },...{|p?:U|}}; (k: { p:T|U });
declare var l: {...{ p?:T },...{|p?:U|}}; (l: { p?:T|U });

declare var m: {|...{|p :T|},...{|p :U|}|}; (m: {|p :  U|});
declare var n: {|...{|p?:T|},...{|p :U|}|}; (n: {|p :  U|});
declare var o: {|...{|p :T|},...{|p?:U|}|}; (o: {|p :T|U|});
declare var p: {|...{|p?:T|},...{|p?:U|}|}; (p: {|p?:T|U|});

=====================================output=====================================
declare class T {}
declare class U {}

declare var a: { ...{ p: T }, ...{ p: U } };
(a: { p: U });
declare var b: { ...{ p?: T }, ...{ p: U } };
(b: { p: U });
declare var c: { ...{ p: T }, ...{ p?: U } };
(c: { p: T | U });
declare var d: { ...{ p?: T }, ...{ p?: U } };
(d: { p?: T | U });

declare var e: { ...{| p: T |}, ...{ p: U } };
(e: { p: U });
declare var f: { ...{| p?: T |}, ...{ p: U } };
(f: { p: U });
declare var g: { ...{| p: T |}, ...{ p?: U } };
(g: { p: T | U });
declare var h: { ...{| p?: T |}, ...{ p?: U } };
(h: { p?: T | U });

declare var i: { ...{ p: T }, ...{| p: U |} };
(i: { p: U });
declare var j: { ...{ p?: T }, ...{| p: U |} };
(j: { p: U });
declare var k: { ...{ p: T }, ...{| p?: U |} };
(k: { p: T | U });
declare var l: { ...{ p?: T }, ...{| p?: U |} };
(l: { p?: T | U });

declare var m: {| ...{| p: T |}, ...{| p: U |} |};
(m: {| p: U |});
declare var n: {| ...{| p?: T |}, ...{| p: U |} |};
(n: {| p: U |});
declare var o: {| ...{| p: T |}, ...{| p?: U |} |};
(o: {| p: T | U |});
declare var p: {| ...{| p?: T |}, ...{| p?: U |} |};
(p: {| p?: T | U |});

================================================================================
`;

exports[`type_statics.js format 1`] = `
====================================options=====================================
parsers: ["flow", "babel"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
class A {static p: number}

type O1 = {...Class<A>};
declare var o1: O1;
(o1: {p?:number}); // ok

=====================================output=====================================
class A {
  static p: number;
}

type O1 = { ...Class<A> };
declare var o1: O1;
(o1: { p?: number }); // ok

================================================================================
`;

exports[`type_string.js format 1`] = `
====================================options=====================================
parsers: ["flow", "babel"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
type O1 = {..."foo"}; // No error
("foo": O1); // Error

=====================================output=====================================
type O1 = { ..."foo" }; // No error
("foo": O1); // Error

================================================================================
`;

exports[`type_union.js format 1`] = `
====================================options=====================================
parsers: ["flow", "babel"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
declare class T {}
declare var x: T;

declare class U {}
declare var y: U;

type O1 = {...{p:T}|{q:U}};
declare var o1: O1;
(o1: {p?:T}|{q?:U}); // ok

type Union1 = {| [string]: number |} | {| foo: number |}
type Union2 = {| bar: number |} | {| [number]: string |};

declare var x1: {...Union1, ...Union2}; // Error, indexer on right
(x1: {});

declare var x5: {...Union1, ...{}} // Error, spreading {} overwrites indexer
(x5: {});

var y = {}; // unsealed

type UnsealedInUnion = Union1 | Union2 | typeof y;
declare var x2: {...UnsealedInUnion}; // Error, unsealed
(x2: {});

type Union3 = {| foo: number |} | {| bar: number |};
type Union4 = {| baz: number  |} | {| qux: number |};
declare var x3: {| ...Union3, ...Union4 |};
(x3: {| foo: number, baz: number|} // Should consider erroring instead of calculating combinatorial blowup
   | {| foo: number, qux: number|}
   | {| bar: number, baz: number|}
   | {| bar: number, qux: number|}
);

interface I1 {}
type Union5 = I1 | Union3 | Union4;
declare var x4: {...Union5};  // Error, cannot spread interface
(x4: {});

=====================================output=====================================
declare class T {}
declare var x: T;

declare class U {}
declare var y: U;

type O1 = { ...{ p: T } | { q: U } };
declare var o1: O1;
(o1: { p?: T } | { q?: U }); // ok

type Union1 = {| [string]: number |} | {| foo: number |};
type Union2 = {| bar: number |} | {| [number]: string |};

declare var x1: { ...Union1, ...Union2 }; // Error, indexer on right
(x1: {});

declare var x5: { ...Union1, ...{} }; // Error, spreading {} overwrites indexer
(x5: {});

var y = {}; // unsealed

type UnsealedInUnion = Union1 | Union2 | typeof y;
declare var x2: { ...UnsealedInUnion }; // Error, unsealed
(x2: {});

type Union3 = {| foo: number |} | {| bar: number |};
type Union4 = {| baz: number |} | {| qux: number |};
declare var x3: {| ...Union3, ...Union4 |};
(x3:
  | {| foo: number, baz: number |} // Should consider erroring instead of calculating combinatorial blowup
  | {| foo: number, qux: number |}
  | {| bar: number, baz: number |}
  | {| bar: number, qux: number |});

interface I1 {}
type Union5 = I1 | Union3 | Union4;
declare var x4: { ...Union5 }; // Error, cannot spread interface
(x4: {});

================================================================================
`;

exports[`type_void.js format 1`] = `
====================================options=====================================
parsers: ["flow", "babel"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

declare class T {}
declare var x: T;

declare class U {}
declare var y: U;

type O1 = {...void};
declare var o1: O1;
(o1: {}); // ok
(o1: {||}); // error
(o1: {p:T}); // error
({}: O1); // ok
({p:x}: O1); // ok

type O2 = {|...void|};
declare var o2: O2;
(o2: {}); // ok
(o2: {||}); // ok
(o2: {p:T}); // error
({}: O2); // error
({p:x}: O2); // error

type O3 = {...null};
declare var o3: O3;
(o3: {}); // ok
(o3: {||}); // error
(o3: {p:T}); // error
({}: O3); // ok
({p:x}: O3); // ok

type O4 = {|...null|};
declare var o4: O4;
(o4: {}); // ok
(o4: {||}); // ok
(o4: {p:T}); // error
({}: O4); // error
({p:x}: O4); // error

type O5 = {...void, ...{p:T}};
declare var o5: O5;
(o5: {p?:T}); // ok
(o5: {p:T}); // error: o5.p is optional
({}: O5); // ok
({p:x}: O5); // ok
({p:y}: O5); // error: y ~> T
({p:x,q:y}: O5); // ok

type O6 = {...{p:T}, ...void};
declare var o6: O6;
(o6: {p?:T}); // error, void doesn't overwrite p
(o6: {p:T}); // ok
({}: O6); // ok
({p:x}: O6); // ok
({p:y}: O6); // error: y ~> T
({p:x,q:y}: O6); // ok

=====================================output=====================================
// @flow

declare class T {}
declare var x: T;

declare class U {}
declare var y: U;

type O1 = { ...void };
declare var o1: O1;
(o1: {}); // ok
(o1: {||}); // error
(o1: { p: T }); // error
({}: O1); // ok
({ p: x }: O1); // ok

type O2 = {| ...void |};
declare var o2: O2;
(o2: {}); // ok
(o2: {||}); // ok
(o2: { p: T }); // error
({}: O2); // error
({ p: x }: O2); // error

type O3 = { ...null };
declare var o3: O3;
(o3: {}); // ok
(o3: {||}); // error
(o3: { p: T }); // error
({}: O3); // ok
({ p: x }: O3); // ok

type O4 = {| ...null |};
declare var o4: O4;
(o4: {}); // ok
(o4: {||}); // ok
(o4: { p: T }); // error
({}: O4); // error
({ p: x }: O4); // error

type O5 = { ...void, ...{ p: T } };
declare var o5: O5;
(o5: { p?: T }); // ok
(o5: { p: T }); // error: o5.p is optional
({}: O5); // ok
({ p: x }: O5); // ok
({ p: y }: O5); // error: y ~> T
({ p: x, q: y }: O5); // ok

type O6 = { ...{ p: T }, ...void };
declare var o6: O6;
(o6: { p?: T }); // error, void doesn't overwrite p
(o6: { p: T }); // ok
({}: O6); // ok
({ p: x }: O6); // ok
({ p: y }: O6); // error: y ~> T
({ p: x, q: y }: O6); // ok

================================================================================
`;
