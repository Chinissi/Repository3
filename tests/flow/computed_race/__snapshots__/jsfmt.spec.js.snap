// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`a.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/* This test ensures that computed properties are considered before allowing
 * writes to happen on the created object.
 *
 * To construct an example with a possible race condition, we create two tvars
 * that will resolve at different times. The \`K\` type and the default export
 * below are imported by b.js and c.js and used in property reads and writes. */

export type K = "FOO";
module.exports = Object.freeze({FOO:"FOO"});

=====================================output=====================================
/* This test ensures that computed properties are considered before allowing
 * writes to happen on the created object.
 *
 * To construct an example with a possible race condition, we create two tvars
 * that will resolve at different times. The \`K\` type and the default export
 * below are imported by b.js and c.js and used in property reads and writes. */

export type K = "FOO";
module.exports = Object.freeze({ FOO: "FOO" });

================================================================================
`;

exports[`b.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/* This test ensures that computed properties are considered before allowing
 * writes to happen on the created object.
 *
 * If the \`A\` require resolves first, we still want to wait for \`K\` to resolve
 * before trying to access the \`A.FOO\` property on \`o\` below. */

import type {K} from "./a";
const A = require("./a");
declare var k: K;
var o = {[k]: null};
(o[A.FOO]: empty); // error: null ~> empty

=====================================output=====================================
/* This test ensures that computed properties are considered before allowing
 * writes to happen on the created object.
 *
 * If the \`A\` require resolves first, we still want to wait for \`K\` to resolve
 * before trying to access the \`A.FOO\` property on \`o\` below. */

import type { K } from "./a";
const A = require("./a");
declare var k: K;
var o = { [k]: null };
(o[A.FOO]: empty); // error: null ~> empty

================================================================================
`;

exports[`c.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/* This test ensures that computed properties are considered before allowing
 * writes to happen on the created object.
 *
 * If the \`K\` type import resolves first, we still want to wait for \`A\` to
 * resolve before trying to access the \`k\` property on \`o\` below. */

import type {K} from "./a";
const A = require("./a");
var o = {[A.FOO]: null};
declare var k: K;
(o[k]: empty); // error: null ~> empty

=====================================output=====================================
/* This test ensures that computed properties are considered before allowing
 * writes to happen on the created object.
 *
 * If the \`K\` type import resolves first, we still want to wait for \`A\` to
 * resolve before trying to access the \`k\` property on \`o\` below. */

import type { K } from "./a";
const A = require("./a");
var o = { [A.FOO]: null };
declare var k: K;
(o[k]: empty); // error: null ~> empty

================================================================================
`;

exports[`lib.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
declare class Object {
  static freeze<T>(o: T): T;
}

=====================================output=====================================
declare class Object {
  static freeze<T>(o: T): T;
}

================================================================================
`;
