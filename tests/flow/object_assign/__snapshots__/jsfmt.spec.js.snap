// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`A.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/**
 * @flow
 */

var EventEmitter = require('events').EventEmitter;

// Bad is deferred on decl merge
var Bad = Object.assign({}, EventEmitter.prototype, {
  foo: function(): string { return 'hi'; }
});

// Calling Bad.foo() adds \`Bad\` as \`this\`-type of \`foo\`
var bad: number = Bad.foo();

// Good is not deferred, as MyEventEmitter is local
class MyEventEmitter extends events$EventEmitter {}
var Good = Object.assign({}, MyEventEmitter.prototype, {
  foo: function(): string { return 'hi'; }
});
// Calling Good.foo() in the same file doesn't error
var good: number = Good.foo();

module.exports = {
  Bad: Bad, // assert_ground doesn't scrub out \`this\` type of \`foo\`
  Good: Good, // assert_ground scrubs out \`this\` type of \`foo\`
};

=====================================output=====================================
/**
 * @flow
 */

var EventEmitter = require("events").EventEmitter;

// Bad is deferred on decl merge
var Bad = Object.assign({}, EventEmitter.prototype, {
  foo: function (): string {
    return "hi";
  },
});

// Calling Bad.foo() adds \`Bad\` as \`this\`-type of \`foo\`
var bad: number = Bad.foo();

// Good is not deferred, as MyEventEmitter is local
class MyEventEmitter extends events$EventEmitter {}
var Good = Object.assign({}, MyEventEmitter.prototype, {
  foo: function (): string {
    return "hi";
  },
});
// Calling Good.foo() in the same file doesn't error
var good: number = Good.foo();

module.exports = {
  Bad: Bad, // assert_ground doesn't scrub out \`this\` type of \`foo\`
  Good: Good, // assert_ground scrubs out \`this\` type of \`foo\`
};

================================================================================
`;

exports[`B.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/**
 * @flow
 */

var A = require('./A.js');

var good: number = A.Good.foo(); // string ~> number

var f = A.Bad.foo; // Property access is fine
var bad_: number = f(); // error: string ~> number

var bad: number = A.Bad.foo(); // error: string, number (but \`this\` types are compatible)

=====================================output=====================================
/**
 * @flow
 */

var A = require("./A.js");

var good: number = A.Good.foo(); // string ~> number

var f = A.Bad.foo; // Property access is fine
var bad_: number = f(); // error: string ~> number

var bad: number = A.Bad.foo(); // error: string, number (but \`this\` types are compatible)

================================================================================
`;

exports[`apply.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

(Object.assign.apply(null, [{}, {a: 1}, {b: 'foo'}]): {a: number, b: string});
(Object.assign.apply(null, [{}, {a: 1}, {b: 2}]): {a: number, b: string}); // error
(Object.assign.apply({}, {a: 1}, {b: 'foo'}): {a: number, b: string}); // error

(Object.assign.call({}, [{a: 1}, {b: 'foo'}]): {a: number, b: string}); // error
(Object.assign.call({}, {a: 1}, {b: 'foo'}): {a: number, b: string});
(Object.assign.call({}, {a: 1}, {b: 2}): {a: number, b: string}); // error

(Object.assign.length : number);
(Object.assign.length : string); // error

(Object.assign.name : number); // error
(Object.assign.name : string);

=====================================output=====================================
// @flow

(Object.assign.apply(null, [{}, { a: 1 }, { b: "foo" }]): {
  a: number,
  b: string,
});
(Object.assign.apply(null, [{}, { a: 1 }, { b: 2 }]): { a: number, b: string }); // error
(Object.assign.apply({}, { a: 1 }, { b: "foo" }): { a: number, b: string }); // error

(Object.assign.call({}, [{ a: 1 }, { b: "foo" }]): { a: number, b: string }); // error
(Object.assign.call({}, { a: 1 }, { b: "foo" }): { a: number, b: string });
(Object.assign.call({}, { a: 1 }, { b: 2 }): { a: number, b: string }); // error

(Object.assign.length: number);
(Object.assign.length: string); // error

(Object.assign.name: number); // error
(Object.assign.name: string);

================================================================================
`;

exports[`non_objects.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/* @flow */

Object.assign("123", {a: "foo"});
Object.assign(123, {a: "foo"});
Object.assign({a: "foo"}, 123);

=====================================output=====================================
/* @flow */

Object.assign("123", { a: "foo" });
Object.assign(123, { a: "foo" });
Object.assign({ a: "foo" }, 123);

================================================================================
`;

exports[`scope.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
//@flow
type Obj = { attr: number | string }

function f(obj: Obj, b: boolean) {
  obj.attr = 42;
  if (b) {
    obj.attr = "hello";
  } else {
    obj.attr = "hello";
  }
}

function g(obj: Obj, b: boolean) {
  obj.attr = 42;
  if (b) {
    obj.attr = "hello";
  }
}


function h(obj: Obj, b: boolean) {
  obj.attr = 42;
  if (obj.attr) {
    obj.attr = "hello";
  }
}

function i(obj: Obj, b: boolean) {
  obj.attr = 42;
  if (b) {
    obj.attr = "hello";
  }
  (obj.attr: number);
}

=====================================output=====================================
//@flow
type Obj = { attr: number | string };

function f(obj: Obj, b: boolean) {
  obj.attr = 42;
  if (b) {
    obj.attr = "hello";
  } else {
    obj.attr = "hello";
  }
}

function g(obj: Obj, b: boolean) {
  obj.attr = 42;
  if (b) {
    obj.attr = "hello";
  }
}

function h(obj: Obj, b: boolean) {
  obj.attr = 42;
  if (obj.attr) {
    obj.attr = "hello";
  }
}

function i(obj: Obj, b: boolean) {
  obj.attr = 42;
  if (b) {
    obj.attr = "hello";
  }
  (obj.attr: number);
}

================================================================================
`;

exports[`spread.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

declare var arrOfObjs: Array<{ foo: string }>;
declare var roArrOfObjs: $ReadOnlyArray<{foo: string}>;
declare var tup: [{foo: string}, {bar: number}];

(Object.assign({}, ...arrOfObjs): { foo: number}); // Error: string ~> number
(Object.assign({}, ...roArrOfObjs): { foo: number}); // Error: string ~> number
(Object.assign({}, ...tup): { foo: string, bar: boolean}); // Error: number ~> boolean

(Object.assign(
  {},
  ...[{a: 1}, {b: 'foo'}],
  ...[{c: true}],
): {a: number, b: true, c: boolean}); // Error: 'foo' => true

=====================================output=====================================
// @flow

declare var arrOfObjs: Array<{ foo: string }>;
declare var roArrOfObjs: $ReadOnlyArray<{ foo: string }>;
declare var tup: [{ foo: string }, { bar: number }];

(Object.assign({}, ...arrOfObjs): { foo: number }); // Error: string ~> number
(Object.assign({}, ...roArrOfObjs): { foo: number }); // Error: string ~> number
(Object.assign({}, ...tup): { foo: string, bar: boolean }); // Error: number ~> boolean

(Object.assign({}, ...[{ a: 1 }, { b: "foo" }], ...[{ c: true }]): {
  a: number,
  b: true,
  c: boolean,
}); // Error: 'foo' => true

================================================================================
`;

exports[`undefined.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/* @flow */

var React = require('react');

type DefaultProps = {
  foo: number,
}

type Props = {
  foo: number,
}

class MyReactThing extends React.Component<Props> {
  static defaultProps: DefaultProps;
  getFoo(): number { return this.props.foo; }
}

<MyReactThing />; // works
<MyReactThing foo={undefined} />; // also works

=====================================output=====================================
/* @flow */

var React = require("react");

type DefaultProps = {
  foo: number,
};

type Props = {
  foo: number,
};

class MyReactThing extends React.Component<Props> {
  static defaultProps: DefaultProps;
  getFoo(): number {
    return this.props.foo;
  }
}

<MyReactThing />; // works
<MyReactThing foo={undefined} />; // also works

================================================================================
`;
