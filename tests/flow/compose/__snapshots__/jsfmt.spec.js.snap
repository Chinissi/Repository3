// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`basic.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

declare var compose: $Compose;
declare var composeReverse: $ComposeReverse;

(compose(n => n.toString())(42): empty); // Error: string ~> empty

(composeReverse(n => n.toString())(42): empty); // Error: string ~> empty

(compose(
  n => n * 5, // Error: string cannot be multiplied.
  n => n.toString(),
)(42): empty); // Error: number ~> empty

(composeReverse(
  n => n * 5, // OK
  n => n.toString(),
)(42): empty); // Error: string ~> empty

=====================================output=====================================
// @flow

declare var compose: $Compose;
declare var composeReverse: $ComposeReverse;

(compose((n) => n.toString())(42): empty); // Error: string ~> empty

(composeReverse((n) => n.toString())(42): empty); // Error: string ~> empty

(compose(
  (n) => n * 5, // Error: string cannot be multiplied.
  (n) => n.toString()
)(42): empty); // Error: number ~> empty

(composeReverse(
  (n) => n * 5, // OK
  (n) => n.toString()
)(42): empty); // Error: string ~> empty

================================================================================
`;

exports[`recompose.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/**
 * @flow
 *
 * This test was taken from:
 * https://github.com/istarkov/flow-compose-error
 */

import { compose } from 'recompose';

// shared code between bad/good Compose
type Comp<A> = (a: A) => void;
type HOC<A, B> = (a: Comp<A>) => Comp<B>;

function myEnhancer<A, B>(mapper: B => A): HOC<A, B> {
  return (comp: Comp<A>) => (props: B) => comp(mapper(props));
}

const enhancer: HOC<*, { p: number, e: string }> = compose(
  myEnhancer(props => ({
    p: \`\${props.p * 3}\`,
  })),
  myEnhancer(props => ({
    c: Math.round(props.p), // Error: string ~> number
  }))
);

=====================================output=====================================
/**
 * @flow
 *
 * This test was taken from:
 * https://github.com/istarkov/flow-compose-error
 */

import { compose } from "recompose";

// shared code between bad/good Compose
type Comp<A> = (a: A) => void;
type HOC<A, B> = (a: Comp<A>) => Comp<B>;

function myEnhancer<A, B>(mapper: (B) => A): HOC<A, B> {
  return (comp: Comp<A>) => (props: B) => comp(mapper(props));
}

const enhancer: HOC<*, { p: number, e: string }> = compose(
  myEnhancer((props) => ({
    p: \`\${props.p * 3}\`,
  })),
  myEnhancer((props) => ({
    c: Math.round(props.p), // Error: string ~> number
  }))
);

================================================================================
`;

exports[`spread.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// @flow

declare var compose: $Compose;
declare var fns1: Array<(number) => number>;
declare var fns2: Array<(number) => string>;
declare var fns3: Array<<O>(O) => $PropertyType<O, 'p'>>;

(compose(
  ...fns1,
)(42): empty); // Error: number ~> empty

(compose(
  ...fns1, // Error: string ~> number
)('foo'): empty); // Error: string ~> empty and number ~> empty

(compose(
  ...fns2, // Error: string ~> number
)(42): empty); // Error: number ~> empty and string ~> empty

const x1 = { p: { p: { p: { p: 42 } } } };
(compose(
  ...fns3, // Error: Cannot get p on number
)(x1): empty); // Error: number ~> empty and object ~> empty

type X2 = { p: X2 };
declare var x2: X2;
((compose(
  ...fns3,
))(x2): empty); // Error: object ~> empty

=====================================output=====================================
// @flow

declare var compose: $Compose;
declare var fns1: Array<(number) => number>;
declare var fns2: Array<(number) => string>;
declare var fns3: Array<<O>(O) => $PropertyType<O, "p">>;

(compose(...fns1)(42): empty); // Error: number ~> empty

(compose(
  ...fns1 // Error: string ~> number
)("foo"): empty); // Error: string ~> empty and number ~> empty

(compose(
  ...fns2 // Error: string ~> number
)(42): empty); // Error: number ~> empty and string ~> empty

const x1 = { p: { p: { p: { p: 42 } } } };
(compose(
  ...fns3 // Error: Cannot get p on number
)(x1): empty); // Error: number ~> empty and object ~> empty

type X2 = { p: X2 };
declare var x2: X2;
(compose(...fns3)(x2): empty); // Error: object ~> empty

================================================================================
`;
