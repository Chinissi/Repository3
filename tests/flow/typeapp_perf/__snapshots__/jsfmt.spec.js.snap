// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`test1.js format 1`] = `
====================================options=====================================
parsers: ["flow", "babel"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/* This test ensures that the code below does not take a long time to check. If
 * this test is taking a very long time to complete, there is a bug. */

class A {}

type B<T> = A & {
  +a: () => B<T>;
  +b: () => B<T>;
  +c: () => B<T>;
  +d: () => B<T>;
  +e: () => B<T>;
  +f: () => B<T>;
  +g: () => B<T>;
  +h: () => B<T>;
  +i: () => B<T>;
};

declare var b: B<any>;

(b: B<any>);

=====================================output=====================================
/* This test ensures that the code below does not take a long time to check. If
 * this test is taking a very long time to complete, there is a bug. */

class A {}

type B<T> = A & {
  +a: () => B<T>,
  +b: () => B<T>,
  +c: () => B<T>,
  +d: () => B<T>,
  +e: () => B<T>,
  +f: () => B<T>,
  +g: () => B<T>,
  +h: () => B<T>,
  +i: () => B<T>,
};

declare var b: B<any>;

(b: B<any>);

================================================================================
`;

exports[`test2.js format 1`] = `
====================================options=====================================
parsers: ["flow", "babel"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/* This test ensures that the code below does not take a long time to check. If
 * this test is taking a very long time to complete, there is a bug. */

class A {}

type B<T> = A & {
  +a: (x: B<T>) => void;
  +b: (x: B<T>) => void;
  +c: (x: B<T>) => void;
  +d: (x: B<T>) => void;
  +e: (x: B<T>) => void;
  +f: (x: B<T>) => void;
  +g: (x: B<T>) => void;
  +h: (x: B<T>) => void;
  +i: (x: B<T>) => void;
};

declare var b: B<any>;

(b: B<any>);

=====================================output=====================================
/* This test ensures that the code below does not take a long time to check. If
 * this test is taking a very long time to complete, there is a bug. */

class A {}

type B<T> = A & {
  +a: (x: B<T>) => void,
  +b: (x: B<T>) => void,
  +c: (x: B<T>) => void,
  +d: (x: B<T>) => void,
  +e: (x: B<T>) => void,
  +f: (x: B<T>) => void,
  +g: (x: B<T>) => void,
  +h: (x: B<T>) => void,
  +i: (x: B<T>) => void,
};

declare var b: B<any>;

(b: B<any>);

================================================================================
`;

exports[`test3.js format 1`] = `
====================================options=====================================
parsers: ["flow", "babel"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/* This test ensures that the typeapp instantiation cache doesn't erroneously
 * equate separate typeapps. Otherwise, we would cache the T=string
 * instantiation in the first arm of the union, then T=number in the second. */

declare class C<T> { m(): T }
declare var x: C<string> | C<number>;
(x.m(): empty); // error: string ~> empty, number ~> empty

=====================================output=====================================
/* This test ensures that the typeapp instantiation cache doesn't erroneously
 * equate separate typeapps. Otherwise, we would cache the T=string
 * instantiation in the first arm of the union, then T=number in the second. */

declare class C<T> {
  m(): T;
}
declare var x: C<string> | C<number>;
(x.m(): empty); // error: string ~> empty, number ~> empty

================================================================================
`;

exports[`test4.js format 1`] = `
====================================options=====================================
parsers: ["flow", "babel"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
/* This test exercises the abstract_targ logic used in the typeapp expansion
 * cache to detect loops involving implicitly instantiated type arguments */

type A<+T> = {
  m<U>(f: T => U): A<U>,
};

type B<+T> = {
  m<U>(f: T => U): B<U>,
}

declare var a: A<number>;
var b: B<number> = a;

=====================================output=====================================
/* This test exercises the abstract_targ logic used in the typeapp expansion
 * cache to detect loops involving implicitly instantiated type arguments */

type A<+T> = {
  m<U>(f: (T) => U): A<U>,
};

type B<+T> = {
  m<U>(f: (T) => U): B<U>,
};

declare var a: A<number>;
var b: B<number> = a;

================================================================================
`;
