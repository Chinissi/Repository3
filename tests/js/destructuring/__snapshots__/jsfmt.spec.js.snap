// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`destructuring.js format 1`] = `
====================================options=====================================
parsers: ["babel", "flow", "typescript"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
const [one, two = null, three = null] = arr;
a = ([s=1,]) => 1
const { children, ...props } = this.props

const { user: { firstName, lastName } } = this.props;

const {
  name: { first, last },
  organisation: { address: { street: orgStreetAddress, postcode: orgPostcode } }
} = user;

function f({ data: { name } }) {}

const UserComponent = function({
  name: { first, last },
  organisation: { address: { street: orgStreetAddress, postcode: orgPostcode } },
}) {
  return
};

const { a, b, c, d: { e } } = someObject;

try {
  // code
} catch ({ data: { message }}) {
  // code
}

try {
  // code
} catch ({ data: { message: { errors }}}) {
  // code
}

const obj = {
  func(id, { blog: { title } }) {
    return id + title;
  },
};

class A {
  func(id, { blog: { title } }) {
    return id + title;
  }
}

=====================================output=====================================
const [one, two = null, three = null] = arr;
a = ([s = 1]) => 1;
const { children, ...props } = this.props;

const { user: { firstName, lastName } } = this.props;

const {
  name: { first, last },
  organisation: {
    address: { street: orgStreetAddress, postcode: orgPostcode },
  },
} = user;

function f({ data: { name } }) {}

const UserComponent = function ({
  name: { first, last },
  organisation: {
    address: { street: orgStreetAddress, postcode: orgPostcode },
  },
}) {
  return;
};

const { a, b, c, d: { e } } = someObject;

try {
  // code
} catch ({ data: { message } }) {
  // code
}

try {
  // code
} catch ({ data: { message: { errors } } }) {
  // code
}

const obj = {
  func(id, { blog: { title } }) {
    return id + title;
  },
};

class A {
  func(id, { blog: { title } }) {
    return id + title;
  }
}

================================================================================
`;

exports[`sibling-arrow-function-object-members.js format 1`] = `
====================================options=====================================
parsers: ["babel", "flow", "typescript"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// small enough for one line:
const f1 = ({ first, second : { third } }) => combine(second, third);

// these arguments should be destructured on multiple lines:
const f2 = ({ a: { data1 }, b: { data2, data3 } }) => f(data1, data2, data3);

// in arrow function arguments nested inside a function call,
// small enough for one line:
registerReducer(({a: { b, c } }) => combine(b, c))

// in arrow function arguments nested inside a function call,
// should be split into multiple lines:
registerReducer(({a: { b, c }, d: {e, f } }) => combine(b, c, e, f))

// in second arrow function argument nested inside a function call,
// XXX TODO should be split into multiple lines:
registerReducer((event, {a: { b, c }, d: {e, f } }) => combine(b, c, e, f))

=====================================output=====================================
// small enough for one line:
const f1 = ({ first, second: { third } }) => combine(second, third);

// these arguments should be destructured on multiple lines:
const f2 = ({
  a: { data1 },
  b: { data2, data3 },
}) => f(data1, data2, data3);

// in arrow function arguments nested inside a function call,
// small enough for one line:
registerReducer(({ a: { b, c } }) => combine(b, c));

// in arrow function arguments nested inside a function call,
// should be split into multiple lines:
registerReducer(({
  a: { b, c },
  d: { e, f },
}) => combine(b, c, e, f));

// in second arrow function argument nested inside a function call,
// XXX TODO should be split into multiple lines:
registerReducer((event, { a: { b, c }, d: { e, f } }) => combine(b, c, e, f));

================================================================================
`;

exports[`sibling-catch-object-members.js format 1`] = `
====================================options=====================================
parsers: ["babel", "flow", "typescript"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// these catch arguments should be destructured on multiple lines:
try {
  // code
} catch ({ first: { info1, info2 }, second: { info3, info4 } }) {
  // code
}

=====================================output=====================================
// these catch arguments should be destructured on multiple lines:
try {
  // code
} catch ({
  first: { info1, info2 },
  second: { info3, info4 },
}) {
  // code
}

================================================================================
`;

exports[`sibling-const-object-members.js format 1`] = `
====================================options=====================================
parsers: ["babel", "flow", "typescript"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// these siblings should be destructured on multiple lines:
const { a: { innerMember }, b: { anotherInnerMember } } = something;

// these siblings are small enough for one line:
const { a: { innerMember2 }, littleSibling } = something;

// small enough for one line:
const {
  tinySibling1,
  tinySibling2,
  tinySibling3
} = something;

// respect blank line within destrucured const object:
const {
  tinySibling4,

  tinySibling5,
  tinySibling6
} = something;

// small enough for one line:
const { a: { innerData } = {} } = thing;

// small enough for one line:
const { firstMember = {}, secondMember = {} } = thing;

// these destructured objects should be split into multiple lines:
const { a: { innerData1, innerData2 } = {}, b: { innerData3 } = {} } = thing;

// XXX TODO [KNOWN REGRESSION] should be split into multiple lines
// due to the deep member:
const { a: { b: { deepMember } } } = abc

=====================================output=====================================
// these siblings should be destructured on multiple lines:
const {
  a: { innerMember },
  b: { anotherInnerMember },
} = something;

// these siblings are small enough for one line:
const { a: { innerMember2 }, littleSibling } = something;

// small enough for one line:
const { tinySibling1, tinySibling2, tinySibling3 } = something;

// respect blank line within destrucured const object:
const {
  tinySibling4,

  tinySibling5,
  tinySibling6,
} = something;

// small enough for one line:
const { a: { innerData } = {} } = thing;

// small enough for one line:
const { firstMember = {}, secondMember = {} } = thing;

// these destructured objects should be split into multiple lines:
const {
  a: { innerData1, innerData2 } = {},
  b: { innerData3 } = {},
} = thing;

// XXX TODO [KNOWN REGRESSION] should be split into multiple lines
// due to the deep member:
const { a: { b: { deepMember } } } = abc;

================================================================================
`;

exports[`sibling-function-object-array-members.js format 1`] = `
====================================options=====================================
parsers: ["babel", "flow", "typescript"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// small enough for one line:
function f1({ first: [inner1, inner2], second }) {}

// XXX TODO: these arguments should be destructured on multiple lines:
function f2({ first: [inner1, inner2], second: [inner3, inner4] }) {}

// XXX TODO: these arguments should be destructured on multiple lines:
function f3({ first: [inner1, inner2], second: { inner3, inner4 } }) {}

=====================================output=====================================
// small enough for one line:
function f1({ first: [inner1, inner2], second }) {}

// XXX TODO: these arguments should be destructured on multiple lines:
function f2({ first: [inner1, inner2], second: [inner3, inner4] }) {}

// XXX TODO: these arguments should be destructured on multiple lines:
function f3({ first: [inner1, inner2], second: { inner3, inner4 } }) {}

================================================================================
`;

exports[`sibling-function-object-members.js format 1`] = `
====================================options=====================================
parsers: ["babel", "flow", "typescript"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
// small enough for one line:
function f1({ first: { inner1, inner2 }, second }) {}

// these arguments should be destructured on multiple lines:
function f2({ first: { inner1, inner2 }, second: { inner3, inner4 } }) {}

// small enough for one line:
function f3({ first: { inner1, inner2 }, second } = {}) {}

// XXX TODO: these arguments should be destructured on multiple lines:
function f4({ a: { inner1, inner2 }, b: { inner3, inner4 } } = {}) {}

const obj = {
  // these arguments should be destructured on multiple lines:
  func({ a: { info1, info2 }, b: { info3, info4 } }) {}
};

class A {
  // these arguments should be destructured on multiple lines:
  func({ a: { info1, info2 }, b: { info3, info4 } }) {}
}

=====================================output=====================================
// small enough for one line:
function f1({ first: { inner1, inner2 }, second }) {}

// these arguments should be destructured on multiple lines:
function f2({
  first: { inner1, inner2 },
  second: { inner3, inner4 },
}) {}

// small enough for one line:
function f3({ first: { inner1, inner2 }, second } = {}) {}

// XXX TODO: these arguments should be destructured on multiple lines:
function f4({ a: { inner1, inner2 }, b: { inner3, inner4 } } = {}) {}

const obj = {
  // these arguments should be destructured on multiple lines:
  func({
    a: { info1, info2 },
    b: { info3, info4 },
  }) {},
};

class A {
  // these arguments should be destructured on multiple lines:
  func({
    a: { info1, info2 },
    b: { info3, info4 },
  }) {}
}

================================================================================
`;
